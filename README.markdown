# Structure and Interpretation of Computer Programs

I'm reading [SICP](http://mitpress.mit.edu/sicp/), watching the [(1986) video lectures(http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/), and trying to complete as many of the programming exercises as I can.

The following list was extracted from the online version of the book. It was a quick and dirty job but gives an overview of which exercises I've completed.


## 1 Building Abstractions with Procedures
<strike>**Exercise 1.1.** Below is a sequence of expressions.  
What is the result printed by the interpreter in response to each
expression?  Assume that the sequence is to be evaluated in the order
in which it is presented.</strike>

<strike>**Exercise 1.2.** Translate the following expression into prefix form
</strike>

<strike>**Exercise 1.3.** Define a procedure that takes three numbers as arguments and returns
the sum of the squares of the two larger numbers.
</strike>

<strike>**Exercise 1.4.** Observe that our model of evaluation allows for combinations whose
operators are compound expressions.  Use this observation to
describe the behavior of the following procedure:
</strike>

<strike>**Exercise 1.5.** Ben Bitdiddle has invented a test to determine whether the interpreter
he is faced with is using applicative-order evaluation or normal-order
evaluation.  He defines the following two procedures:
</strike>

<strike>**Exercise 1.6.** Alyssa P. Hacker doesn't see why <tt>if</tt> needs
to be provided as a special form.  ``Why can't I just define it as an
ordinary procedure in terms of <tt>cond</tt>?'' she asks.
Alyssa's friend Eva Lu Ator claims this can indeed be done, and
she defines a new version of <tt>if</tt>:</strike>

<strike>**Exercise 1.7.** The <tt>good-enough?</tt> test used in computing square roots will not be
very effective for finding the square roots of very small numbers.
Also, in real computers, arithmetic operations are almost always
performed with limited precision.  This makes our test inadequate for
very large numbers.  Explain these statements, with examples showing
how the test fails for small and large numbers.  An alternative
strategy for implementing <tt>good-enough?</tt> is to watch how <tt>guess</tt> changes from one iteration to the next and to stop when the
change is a very small fraction of the guess.  Design a square-root
procedure that uses this kind of end test.  Does this work better for
small and large numbers?
</strike>

<strike>**Exercise 1.8.** Newton's method for cube roots is based on the fact that if *y* is an
approximation to the cube root of *x*, then a better approximation is
given by the value
</strike>

<strike>**Exercise 1.9.** Each of the following two procedures defines a method for adding two
positive integers in terms of the procedures <tt>inc</tt>,
which increments its argument by 1, and <tt>dec</tt>, which decrements
its argument by 1.</strike>

<strike>**Exercise 1.10.** The following procedure computes a mathematical function called
Ackermann's function.</strike>

<strike>**Exercise 1.11.** A function *f* is defined by the rule that *f*(*n*) = *n* if *n*&lt;3 and
*f*(*n*) = *f*(*n* - 1) + 2*f*(*n* - 2) + 3*f*(*n* - 3) if *n*<u>&gt;</u> 3.  Write a procedure that
computes *f* by means of a recursive process.  Write a procedure that
computes *f* by means of an iterative process.
</strike>

<strike>**Exercise 1.12.** The following pattern of numbers is called
*Pascal's triangle*.</strike>

**Exercise 1.13.** Prove that  *F**i**b*(*n*) is the closest integer to <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-11.gif' /><sup><em>n</em></sup>/<img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif' />5,
where <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-11.gif' /> =  (1 + <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif' />5)/2.  Hint: Let <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-12.gif' /> =  (1 - <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif' />5)/2.  Use
induction and the definition of the Fibonacci numbers (see
section 1.2.2) to prove that  *F**i**b*(*n*) = (<img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-11.gif' /><sup><em>n</em></sup>
 - <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-12.gif' /><sup><em>n</em></sup>)/<img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif' />

**Exercise 1.14.** Draw the tree illustrating the process generated by the <tt>count-change</tt> procedure of section 1.2.2 in making
change for 11 cents.  What are the orders of growth of the space and
number of steps used by this process as the amount to be changed
increases?


**Exercise 1.15.** The sine of an angle (specified in
radians) can be computed by making use of the approximation
<tt>sin</tt> *x* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-20.gif' />*x*
if *x* is
sufficiently small, and the trigonometric identity 


<strike>**Exercise 1.16.** Design a procedure that evolves an iterative exponentiation process
that uses successive squaring and uses a logarithmic number of steps,
as does <tt>fast-expt</tt>.  (Hint: Using the observation that
(*b*<sup><em>n</em>/2</sup>)<sup>2</sup>  = (*b*<sup>2</sup>)<sup><em>n</em>/2</sup>, keep, along with the exponent *n* and the
base *b*, an additional state variable *a*, and define the state
transformation in such a way that the product *a* *b*<sup><em>n</em></sup> is unchanged
from state to state.  At the beginning of the process *a* is taken to
be 1, and the answer is given by the value of *a* at the end of the
process.  In general, the technique of defining an *invariant
quantity* that remains unchanged from state to state is a powerful way
to think about the </strike>

<strike>**Exercise 1.17.** The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication.  In a similar way,
one can perform integer multiplication by means of repeated addition.
The following multiplication procedure (in which it is assumed that
our language can only add, not multiply) is analogous to the <tt>expt</tt> procedure:</strike>

<strike>**Exercise 1.18.** Using the results of exercises 1.16
and 1.17, devise a procedure that generates an iterative
process for multiplying two integers in terms of adding, doubling, and
halving and uses a logarithmic number of steps.<sup><small>40</small></sup></strike>

<strike>**Exercise 1.19.** 
There is a clever algorithm for computing the Fibonacci numbers in
a logarithmic number of steps.
Recall the transformation of the state variables
*a* and *b* in the <tt>fib-iter</tt> process of
section 1.2.2: *a* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-14.gif' />*a* + *b* and *b* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-14.gif' />*a*.  Call this transformation *T*, and observe that applying *T* over
and over again *n* times, starting with 1 and 0, produces the pair
 *F**i**b*(*n* + 1) and  *F**i**b*(*n*).  In other words, the Fibonacci
numbers are produced by applying *T*<sup><em>n</em></sup>, the *n*th power of the
transformation *T*, starting with the pair (1,0).  Now consider *T*
to be the special case of *p* = 0 and *q* = 1 in a family of
transformations *T*<sub><em>p</em><em>q</em></sub>, where *T*<sub><em>p</em><em>q</em></sub> transforms the pair (*a*,*b*)
according to *a* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-14.gif' />*b**q* + *a**q* + *a**p* and *b* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-14.gif' />*b**p* + *a**q*.  Show
that if we apply such a transformation *T*<sub><em>p</em><em>q</em></sub> twice, the effect is
the same as using a single transformation *T*<sub><em>p</em>'<em>q</em>'</sub> of the same form,
and compute *p*' and *q*' in terms of *p* and *q*.  This gives us an
explicit way to square these transformations, and thus we can compute
*T*<sup><em>n</em></sup> using successive squaring, as in the <tt>fast-expt</tt>
procedure.  Put this all together to complete the following procedure,
which runs in a logarithmic number of steps:<sup><small>41</small></sup></strike>

**Exercise 1.20.** The process that a procedure generates is of course dependent on the
rules used by the interpreter.  As an example, consider the iterative
<tt>gcd</tt> procedure given above.
Suppose we were to interpret this procedure using normal-order
evaluation, as discussed in section 1.1.5.
(The normal-order-evaluation rule for <tt>if</tt> is described in
exercise 1.5.)  Using the
substitution method (for normal order), illustrate the process
generated in evaluating <tt>(gcd 206 40)</tt> and indicate the
<tt>remainder</tt> operations that are actually performed.
How many <tt>remainder</tt> operations are actually performed
in the normal-order evaluation of <tt>(gcd 206&nbsp;40)</tt>?
In the applicative-order evaluation?


<strike>**Exercise 1.21.** Use the <tt>smallest-divisor</tt> procedure to find the smallest divisor
of each of the following numbers: 199, 1999, 19999.
</strike>

<strike>**Exercise 1.22.** Most Lisp implementations include a primitive called <tt>runtime</tt>
that returns an integer that specifies the amount of time the system
has been running (measured, for example, in microseconds).  The
following <tt>timed-prime-test</tt> procedure, when called with an
integer *n*, prints *n* and checks to see if *n* is prime.  If *n* is
prime, the procedure prints three asterisks followed by the amount of time
used in performing the test.</strike>

<strike>**Exercise 1.23.** The <tt>smallest-divisor</tt> procedure shown at the start of this section
does lots of needless testing: After it checks to see if the
number is divisible by 2 there is no point in checking to see if
it is divisible by any larger even numbers.  This suggests that the
values used for <tt>test-divisor</tt> should not be 2, 3, 4, 5, 6,
<tt>...</tt>, but rather 2, 3, 5, 7, 9, <tt>...</tt>.  To implement this
change, define a procedure <tt>next</tt> that returns 3 if its input is
equal to 2 and otherwise returns its input plus 2.  Modify the <tt>smallest-divisor</tt> procedure to use <tt>(next test-divisor)</tt> instead
of <tt>(+ test-divisor 1)</tt>.  With <tt>timed-prime-test</tt>
incorporating this modified version of <tt>smallest-divisor</tt>, run the
test for each of the 12 primes found in
exercise 1.22.  Since this modification halves the
number of test steps, you should expect it to run about twice as fast.
Is this expectation confirmed?  If not, what is the observed ratio of
the speeds of the two algorithms, and how do you explain the fact that
it is different from 2?
</strike>

<strike>**Exercise 1.24.** Modify the <tt>timed-prime-test</tt> procedure of
exercise 1.22 to use <tt>fast-prime?</tt> (the
Fermat method), and test each of the 12 primes you found in that
exercise.  Since the Fermat test has <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-3.gif' />(<tt>log</tt> *n*</strike>

**Exercise 1.25.** Alyssa P. Hacker complains that we went to a lot of extra work in
writing <tt>expmod</tt>.  After all, she says, since we already know how
to compute exponentials, we could have simply written

<strike>**Exercise 1.26.** Louis Reasoner is having great difficulty doing
exercise 1.24.  His <tt>fast-prime?</tt> test
seems to run more slowly than his <tt>prime?</tt> test.  Louis calls his
friend Eva Lu Ator over to help.  When they examine Louis's code, they
find that he has rewritten the <tt>expmod</tt> procedure to use an
explicit multiplication, rather than calling <tt>square</tt>:</strike>

<strike>**Exercise 1.27.** Demonstrate that the Carmichael numbers listed in
footnote 47 really do fool
the Fermat test.  That is, write a procedure that takes an integer *n*
and tests whether *a*<sup><em>n</em></sup> is congruent to *a* modulo *n* for every
*a*&lt;*n*, and try your procedure on the given Carmichael numbers.
</strike>

**Exercise 1.28.** One variant of the Fermat test that cannot be fooled is called the
*Miller-Rabin test* (Miller 1976; Rabin 1980).  This starts from
an alternate form of Fermat's Little Theorem, which states that if *n*
is a prime number and *a* is any positive integer less than *n*, then
*a* raised to the (*n* - 1)st power is congruent to 1 modulo *n*.  To test
the primality of a number *n* by the Miller-Rabin test, we pick a
random number *a*&lt;*n* and raise *a* to the (*n* - 1)st power modulo *n*
using the <tt>expmod</tt> procedure.  However, whenever we perform the
squaring step in <tt>expmod</tt>, we check to see if we have discovered a
``nontrivial square root of 1 modulo *n*,'' that is, a number not
equal to 1 or *n* - 1 whose square is equal to 1 modulo *n*.  It is
possible to prove that if such a nontrivial square root of 1 exists,
then *n* is not prime.  It is also possible to prove that if *n* is an
odd number that is not prime, then, for at least half the numbers
*a*&lt;*n*, computing *a*<sup><em>n</em>-1</sup> in this way will reveal a nontrivial
square root of 1 modulo *n*.  (This is why the Miller-Rabin test
cannot be fooled.)  Modify the <tt>expmod</tt> procedure to signal if it
discovers a nontrivial square root of 1, and use this to implement
the Miller-Rabin test with a procedure analogous to <tt>fermat-test</tt>.
Check your procedure by testing various known primes and non-primes.
Hint: One convenient way to make <tt>expmod</tt>

<strike>**Exercise 1.29.** Simpson's Rule is a more accurate method of numerical integration than
the method illustrated above.  Using Simpson's Rule, the integral of a
function *f* between *a* and *b* is approximated as
</strike>

<strike>**Exercise 1.30.** The <tt>sum</tt> procedure above generates a linear recursion.  The
procedure can be rewritten so that the sum is performed iteratively.
Show how to do this by filling in the missing expressions in the
following definition:</strike>

<strike>**Exercise 1.31.** 


a. The <tt>sum</tt> procedure is only the simplest of a vast number of
similar abstractions that can be captured as higher-order procedures.<sup><small>51</small></sup>  Write an analogous procedure
called <tt>product</tt> that returns the product of the values of a
function at points over a given range.
Show how to define <tt>factorial</tt> in terms of
<tt>product</tt>.  Also use <tt>product</tt> to compute approximations to
<img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-9.gif' /> using the formula<sup><small>52</small></sup></strike>

<strike>**Exercise 1.32.** a. Show that <tt>sum</tt> and <tt>product</tt>
(exercise 1.31) are both special cases of a still more
general notion called <tt>accumulate</tt> that combines a collection of
terms, using some general accumulation function:</strike>

<strike>**Exercise 1.33.** You can obtain an even more general version of <tt>accumulate</tt>
(exercise 1.32) by introducing the notion of a *filter* on the terms to be combined.  That is, combine only those
terms derived from values in the range that satisfy a specified
condition.  The resulting <tt>filtered-accumulate</tt> abstraction takes
the same arguments as accumulate, together with an additional
predicate of one argument that specifies the filter.  Write <tt>filtered-accumulate</tt> as a procedure.  Show how to express the
following using <tt>filtered-accumulate</tt>:</strike>

**Exercise 1.34.** Suppose we define the procedure

**Exercise 1.35.** Show that the golden ratio <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-11.gif' /> (section 1.2.2)
is a fixed point of the transformation *x*  <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />  1  +  1/*x*, and use
this fact to compute <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-11.gif' /> by means of the <tt>fixed-point</tt>
procedure.


<strike>**Exercise 1.36.** Modify <tt>fixed-point</tt> so that it prints the sequence of
approximations it generates, using
the <tt>newline</tt> and <tt>display</tt> primitives shown in
exercise 1.22.  Then find a solution to *x*<sup><em>x</em></sup>  = 
1000 by finding a fixed point of *x*  <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' /><tt>log</tt>(1000)/<tt>log</tt>(*x*).  (Use
Scheme's primitive <tt>log</tt> procedure, which computes natural
logarithms.)  Compare the number of steps this takes with and without
average damping.  (Note that you cannot start <tt>fixed-point</tt> with a
guess of 1, as this would cause division by <tt>log</tt></strike>

**Exercise 1.37.** a. An infinite *continued fraction* is an expression of the form


**Exercise 1.38.** In 1737, the Swiss mathematician Leonhard Euler published a memoir
*De Fractionibus Continuis*, which included a continued fraction
expansion for *e* - 2, where *e* is the base of the natural logarithms.
In this fraction, the *N*<sub><em>i</em></sub> are all 1, and the *D*<sub><em>i</em></sub> are successively
1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, <tt>...</tt>.  Write a program that uses
your <tt>cont-frac</tt> procedure from
exercise 1.37 to approximate *e*, based on
Euler's expansion.


**Exercise 1.39.** A continued fraction representation of the tangent function was
published in 1770 by the German mathematician J.H. Lambert:


<strike>**Exercise 1.40.** Define a procedure <tt>cubic</tt> that can be used together with the <tt>newtons-method</tt> procedure in expressions of the form</strike>

<strike>**Exercise 1.41.** Define a procedure <tt>double</tt> that takes a procedure of one
argument as argument and
returns a procedure that applies the original procedure twice.  For
example, if <tt>inc</tt> is a procedure that adds 1 to its argument,
then <tt>(double inc)</tt> should be a procedure that adds 2.  What
value is returned by</strike>

<strike>**Exercise 1.42.** Let *f* and *g* be two one-argument functions.  The *composition**f* after *g* is defined to be the function *x* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />*f*(*g*(*x*)).
Define a procedure <tt>compose</tt> that implements composition.  For
example, if <tt>inc</tt></strike>

**Exercise 1.43.** If *f* is a numerical function and *n* is a positive integer, then we
can form the *n*th repeated application of *f*, which is defined to be
the function whose value at *x* is *f*(*f*(<tt>...</tt>(*f*(*x*))<tt>...</tt>)).  For
example, if *f* is the function *x*  <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />*x* + 1,
then the *n*th repeated application of *f* is
the function *x*  <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />*x* + *n*.  If *f* is the operation of
squaring a number, then the *n*th repeated application of *f* is the
function that raises its argument to the 2<sup><em>n</em></sup>th power.  Write a
procedure that takes as inputs a procedure that computes *f* and a
positive integer *n* and returns the procedure that computes the *n*th
repeated application of *f*.  Your procedure should be able to be used
as follows:

**Exercise 1.44.** The idea of *smoothing* a function is an important concept in
signal processing.  If *f* is a function and *d**x* is some small number,
then the smoothed version of *f* is the function whose value at a
point *x* is the average of *f*(*x* - *d**x*), *f*(*x*), and *f*(*x* + *d**x*).  Write a
procedure <tt>smooth</tt> that takes as input a procedure that computes
*f* and returns a procedure that computes the smoothed *f*.  It is
sometimes valuable to repeatedly smooth a function (that is, smooth
the smoothed function, and so on) to obtained the *<em>n</em>-fold
smoothed function*.  Show how to generate the *n*-fold smoothed
function of any given function using <tt>smooth</tt> and <tt>repeated</tt>
from exercise 1.43.


**Exercise 1.45.** We saw in section 1.3.3
that attempting to compute square roots by naively finding a
fixed point of *y* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />*x*/*y* does not converge, and that this can be
fixed by average damping.  The same method works for finding cube
roots as fixed points of the average-damped *y* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />*x*/*y*<sup>2</sup>.
Unfortunately, the process does not work for fourth roots -- a single
average damp is not enough to make a fixed-point search for *y* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />*x*/*y*<sup>3</sup> converge.  On the other hand, if we average damp twice (i.e.,
use the average damp of the average damp of *y* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />*x*/*y*<sup>3</sup>) the
fixed-point search does converge.  Do some experiments to determine
how many average damps are required to compute *n*th roots as a
fixed-point search based upon repeated average damping of *y* <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-17.gif' />*x*/*y*<sup><em>n</em>-1</sup>.  Use this to implement a simple procedure for computing
*n*th roots using <tt>fixed-point</tt>, <tt>average-damp</tt>, and the <tt>repeated</tt> procedure of exercise 1.43

**Exercise 1.46.** Several of the numerical methods described in this chapter are instances
of an extremely general computational strategy known as *iterative
improvement*.  Iterative improvement says that, to compute something,
we start with an initial guess for the answer, test if the guess is
good enough, and otherwise improve the guess and continue the process
using the improved guess as the new guess.  Write a procedure <tt>iterative-improve</tt> that takes two procedures as arguments: a method
for telling whether a guess is good enough and a method for improving
a guess.  <tt>Iterative-improve</tt> should return as its value a
procedure that takes a guess as argument and keeps improving the guess
until it is good enough.  Rewrite the <tt>sqrt</tt> procedure of
section 1.1.7 and the <tt>fixed-point</tt> procedure of
section 1.3.3 in terms of <tt>iterative-improve</tt>.


## 2 Building Abstractions with Data
<strike>**Exercise 2.1.** Define a better version of <tt>make-rat</tt> that
handles both positive and negative arguments.  <tt>Make-rat</tt> should
normalize the sign so that if the rational number is positive, both
the numerator and denominator are positive, and if the rational number
is negative, only the numerator is negative.
</strike>

<strike>**Exercise 2.2.** Consider the problem of representing 
line segments in a plane.  Each segment is
represented as a pair of points: a starting point and an ending point.
Define a constructor <tt>make-segment</tt> and selectors <tt>start-segment</tt>
and <tt>end-segment</tt> that define the representation of segments in
terms of points.  Furthermore, a point can be represented as a pair
of numbers: the *x* coordinate and the *y* coordinate.  Accordingly,
specify a constructor <tt>make-point</tt> and selectors <tt>x-point</tt> and
<tt>y-point</tt> that define this representation.  Finally, using your
selectors and constructors, define a procedure <tt>midpoint-segment</tt>
that takes a line segment as argument and returns its midpoint (the
point whose coordinates are the average of the coordinates of the
endpoints).
To try your procedures, you'll need a way to print points:</strike>

**Exercise 2.3.** Implement a representation for rectangles in a plane.
(Hint: You may want to make use of exercise 2.2

<strike>**Exercise 2.4.** Here is an alternative procedural representation of pairs.  For this
representation, verify that <tt>(car (cons x y))</tt> yields <tt>x</tt> for
any objects <tt>x</tt> and <tt>y</tt>.</strike>

<strike>**Exercise 2.5.** Show that we can represent pairs of nonnegative integers using only
numbers and arithmetic operations if we represent the pair *a* and *b*
as the integer that is the product 2<sup><em>a</em></sup> 3<sup><em>b</em></sup>.  Give the corresponding
definitions of the procedures <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.
</strike>

<strike>**Exercise 2.6.** In case representing pairs as procedures wasn't mind-boggling enough,
consider that, in a language that can manipulate procedures, we can
get by without numbers (at least insofar as nonnegative integers are
concerned) by implementing 0 and the operation of adding 1 as</strike>

<strike>**Exercise 2.7.** Alyssa's program is incomplete because she has not specified the
implementation of the interval abstraction.  Here is a definition of
the interval constructor:</strike>

**Exercise 2.8.** Using reasoning analogous to Alyssa's, describe how the difference
of two intervals may be computed.  Define a corresponding subtraction
procedure, called <tt>sub-interval</tt>.


**Exercise 2.9.** The *width* of an interval is half of the difference between its
upper and lower bounds.  The width is a measure of the uncertainty of
the number specified by the interval.  For some arithmetic operations
the width of the result of combining two intervals is a function only
of the widths of the argument intervals, whereas for others the width
of the combination is not a function of the widths of the argument
intervals.  Show that the width of the sum (or difference) of two
intervals is a function only of the widths of the intervals being
added (or subtracted).  Give examples to show that this is not true
for multiplication or division.


**Exercise 2.10.** Ben Bitdiddle, an expert systems programmer, looks over Alyssa's
shoulder and comments that it is not clear what it means to
divide by an interval that spans zero.  Modify Alyssa's code to
check for this condition and to signal an error if it occurs.


<strike>**Exercise 2.11.** In passing, Ben also cryptically comments: ``By testing the signs of
the endpoints of the intervals, it is possible to break <tt>mul-interval</tt> into nine cases, only one of which requires more than
two multiplications.''  Rewrite this procedure using Ben's
suggestion.
</strike>

<strike>**Exercise 2.12.** Define a constructor <tt>make-center-percent</tt> that takes a center and
a percentage tolerance and produces the desired interval.  You must
also define a selector <tt>percent</tt> that produces the
percentage tolerance for a given interval.  The <tt>center</tt></strike>

<strike>**Exercise 2.13.** Show that under the assumption of small percentage tolerances there is
a simple formula for the approximate percentage tolerance of the
product of two intervals in terms of the tolerances of the factors.
You may simplify the problem by assuming that all numbers are
positive.
</strike>

<strike>**Exercise 2.14.** Demonstrate that Lem is right. Investigate the behavior of the
system on a variety of arithmetic expressions. Make some intervals *A* and *B*,
and use them in computing the expressions *A*/*A* and *A*/*B*.  You will
get the most insight by using intervals whose width is a small
percentage of the center value. Examine the results of the computation
in center-percent form (see exercise 2.12).
</strike>

**Exercise 2.15.** Eva Lu Ator, another user, has also noticed the different intervals
computed by different but algebraically equivalent expressions. She
says that a formula to compute with intervals using Alyssa's system
will produce tighter error bounds if it can be written in such a form
that no variable that represents an uncertain number is repeated.
Thus, she says, <tt>par2</tt> is a ``better'' program for parallel
resistances than <tt>par1</tt>.  Is she right?  Why?


**Exercise 2.16.** Explain, in general, why equivalent algebraic expressions may lead to
different answers.  Can you devise an interval-arithmetic package that
does not have this shortcoming, or is this task impossible?  (Warning:
This problem is very difficult.)


<strike>**Exercise 2.17.** Define a procedure <tt>last-pair</tt> that returns the list that contains only
the last element of a given (nonempty) list:</strike>

<strike>**Exercise 2.18.** Define a procedure <tt>reverse</tt> that takes a list as argument and
returns a list of the same elements in reverse order:</strike>

**Exercise 2.19.** Consider the change-counting program of
section 1.2.2.  It would be nice to be able to
easily change the currency used by the program, so that we could
compute the number of ways to change a British pound, for example.  As
the program is written, the knowledge of the currency is distributed
partly into the procedure <tt>first-denomination</tt> and partly into the
procedure <tt>count-change</tt> (which knows that there are five
kinds of U.S. coins).  It would be nicer to be able to
supply a list of coins to be used for making change.

<strike>**Exercise 2.20.** The procedures <tt>+</tt>, <tt>*</tt>, and <tt>list</tt> take arbitrary numbers
of arguments. One way to define such procedures is to use <tt>define</tt>
with *dotted-tail notation*.  In a procedure definition, a parameter
list that has a dot before the last parameter name indicates that, when the
procedure is called, the initial parameters (if any) will have as values
the initial arguments,
as usual, but the final parameter's value will be a *list*</strike>

<strike>**Exercise 2.21.** The procedure <tt>square-list</tt> takes a list of
numbers as argument and returns a list of the squares of those
numbers.</strike>

<strike>**Exercise 2.22.** Louis Reasoner tries to rewrite the first <tt>square-list</tt> procedure of
exercise 2.21 so that it evolves an iterative
process:</strike>

<strike>**Exercise 2.23.** The procedure <tt>for-each</tt> is similar to <tt>map</tt>.  It takes as
arguments a procedure and a list of elements.  However, rather than
forming a list of the  results, <tt>for-each</tt> just applies the procedure
to each of the elements in turn, from left to right.  The values
returned by applying the procedure to the elements are not used at
all -- <tt>for-each</tt> is used with procedures that perform an action,
such as printing.  For example,
</strike>

**Exercise 2.24.** Suppose we evaluate the expression <tt>(list 1 (list 2 (list 3 4)))</tt>.
Give the result printed by the interpreter, the corresponding
box-and-pointer structure, and the interpretation of this as a tree
(as in figure 2.6).


**Exercise 2.25.** Give combinations of <tt>car</tt>s and <tt>cdr</tt>s that will pick 7 from
each of the following lists:

**Exercise 2.26.** Suppose we define <tt>x</tt> and <tt>y</tt> to be two lists:

**Exercise 2.27.** Modify your <tt>reverse</tt> procedure of exercise 2.18 to
produce a <tt>deep-reverse</tt> procedure that takes a list as argument
and returns as its value the list with its elements reversed and with
all sublists deep-reversed as well.  For example,

<strike>**Exercise 2.28.** Write a procedure <tt>fringe</tt> that takes as argument a tree
(represented as a list) and returns a list whose elements are all the
leaves of the tree arranged in left-to-right order.  For example,</strike>

<strike>**Exercise 2.29.** A binary mobile consists of two branches, a left branch and a right
branch.  Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile.  We can represent a binary
mobile using compound data by constructing it from two branches (for
example, using <tt>list</tt>):</strike>

<strike>**Exercise 2.30.** Define a procedure <tt>square-tree</tt> analogous to the <tt>square-list</tt>
procedure of exercise 2.21.  That is, <tt>square-list</tt> should behave as follows:</strike>

**Exercise 2.31.** Abstract your answer to exercise 2.30 to produce a
procedure <tt>tree-map</tt> with the property that <tt>square-tree</tt>
could be defined as

<strike>**Exercise 2.32.** We can represent a set as a list of distinct elements, and we can
represent the set of all subsets of the set as a list of lists.  For
example, if the set is <tt>(1&nbsp;2&nbsp;3)</tt>, then the set of all subsets is
<tt>(() (3) (2) (2&nbsp;3) (1) (1&nbsp;3) (1&nbsp;2) (1&nbsp;2&nbsp;3))</tt>.  Complete the
following definition of a procedure that generates the set of subsets
of a set and give a clear explanation of why it works:
</strike>

<strike>**Exercise 2.33.** Fill in the missing expressions to complete the following definitions
of some basic list-manipulation operations as accumulations:
</strike>

**Exercise 2.34.** Evaluating a polynomial in *x* at a given value of *x* can be
formulated as an accumulation.  We evaluate the polynomial


**Exercise 2.35.** Redefine <tt>count-leaves</tt> from section 2.2.2 as an
accumulation:


**Exercise 2.36.** The procedure <tt>accumulate-n</tt> is similar to <tt>accumulate</tt> except
that it takes as its third argument a sequence of sequences, which are all
assumed to have the same number of elements.  It applies the
designated accumulation procedure to combine all the first elements of
the sequences, all the second elements of the sequences, and so on, and
returns a sequence of the results.  For instance, if <tt>s</tt> is a sequence
containing four sequences, <tt>((1 2 3) (4 5 6) (7 8 9) (10 11 12)),</tt>
then the value of <tt>(accumulate-n + 0 s)</tt> should be the sequence <tt>(22 26 30)</tt>.  Fill in the missing expressions
in the following definition of <tt>accumulate-n</tt>:


**Exercise 2.37.** Suppose we represent vectors *v* = (*v*<sub><em>i</em></sub>) as sequences of numbers, and
matrices *m* = (*m*<sub><em>i</em><em>j</em></sub>) as sequences of vectors (the rows of the matrix).
For example, the matrix


**Exercise 2.38.** The <tt>accumulate</tt> procedure is also known as <tt>fold-right</tt>,
because it combines the first element of the sequence with the result
of combining all the elements to the right.  There is also a <tt>fold-left</tt>, which is 
similar to <tt>fold-right</tt>, except
that it combines elements working in the opposite direction:


<strike>**Exercise 2.39.** 
Complete the following definitions of <tt>reverse</tt>(exercise 2.18) in terms of <tt>fold-right</tt> and <tt>fold-left</tt> from exercise 2.38:
</strike>

**Exercise 2.40.** Define a procedure <tt>unique-pairs</tt> that, given an integer *n*,
generates the sequence of pairs (*i*,*j*) with 1<u>&lt;</u> *j*&lt; *i*<u>&lt;</u> *n*.  Use <tt>unique-pairs</tt> to simplify the definition of <tt>prime-sum-pairs</tt>
given above.


**Exercise 2.41.** Write a procedure to find all ordered
triples of distinct positive integers *i*, *j*, and *k* less than or
equal to a given integer *n* that sum to a given integer *s*.


<strike>**Exercise 2.42.** </strike>

**Exercise 2.43.** Louis Reasoner is having a terrible time doing exercise 2.42.  His
<tt>queens</tt> procedure seems to work, but it runs extremely slowly.
(Louis never does manage to wait long enough for it to solve even the
6&times; 6 case.)  When Louis asks Eva Lu Ator for help, she points
out that he has interchanged the order of the nested mappings in the
<tt>flatmap</tt>, writing it as


<strike>**Exercise 2.44.** Define the procedure <tt>up-split</tt> used by <tt>corner-split</tt>.
It is similar to <tt>right-split</tt>, except that it switches the
roles of <tt>below</tt> and <tt>beside</tt></strike>

**Exercise 2.45.** <tt>Right-split</tt> and <tt>up-split</tt> can be expressed as
instances of a general splitting operation.
Define a procedure <tt>split</tt> with the property that evaluating


<strike>**Exercise 2.46.** A two-dimensional vector **v** running from the origin to a point
can be represented as a pair
consisting of an *x*-coordinate and a *y*-coordinate.  Implement a data
abstraction for vectors by giving a constructor <tt>make-vect</tt> and
corresponding selectors <tt>xcor-vect</tt> and <tt>ycor-vect</tt>.  In
terms of your selectors and constructor, implement procedures <tt>add-vect</tt>, <tt>sub-vect</tt>, and <tt>scale-vect</tt> that perform
the operations vector addition, vector subtraction, and multiplying a
vector by a scalar:
</strike>

<strike>**Exercise 2.47.** Here are two possible constructors for frames:
</strike>

<strike>**Exercise 2.48.** A directed line segment in the
plane can be represented as a pair of vectors -- the
vector running from the origin to the start-point of the segment, and
the vector running from the origin to the end-point of the segment.
Use your vector representation from exercise 2.46 to
define a representation for segments with a constructor <tt>make-segment</tt> and selectors <tt>start-segment</tt> and <tt>end-segment</tt></strike>

<strike>**Exercise 2.49.** Use <tt>segments-&gt;painter</tt> to define the following primitive painters:</strike>

<strike>**Exercise 2.50.** Define the transformation <tt>flip-horiz</tt></strike>

**Exercise 2.51.** Define the <tt>below</tt> operation for painters.  <tt>Below</tt> takes two
painters as arguments.  The resulting painter, given a frame,
draws with the first painter in the
bottom of the frame and with the second painter in the top.  Define <tt>below</tt> in two different ways -- first by writing a procedure that is
analogous to the <tt>beside</tt> procedure given above, and
again in terms of <tt>beside</tt> and suitable
rotation operations (from exercise 2.50

**Exercise 2.52.** Make changes to the square limit of <tt>wave</tt> shown in
figure 2.9 by working at each of the levels
described above.  In particular:

<strike>**Exercise 2.53.** What would the interpreter print in response to evaluating each of the
following expressions?</strike>

**Exercise 2.54.** Two lists are said to be <tt>equal?</tt> if they contain equal elements
arranged in the same order.  For example,

**Exercise 2.55.** Eva Lu Ator types to the interpreter the expression


<strike>**Exercise 2.56.** Show how to extend the basic differentiator to handle more kinds of
expressions.  For instance, implement the differentiation rule</strike>

**Exercise 2.57.** Extend the differentiation program to handle sums and products of
arbitrary numbers of (two or more) terms.
Then the last example above could be expressed as


**Exercise 2.58.** Suppose we want to modify the differentiation program so that it works
with ordinary mathematical notation, in which <tt>+</tt> and <tt>*</tt> are
infix rather than prefix operators.  Since the differentiation program
is defined in terms of abstract data, we can modify it to work with
different representations of expressions solely by changing the
predicates, selectors, and constructors that define the representation
of the algebraic expressions on which the differentiator is to
operate.

<strike>**Exercise 2.59.** Implement the <tt>union-set</tt> operation for the unordered-list
representation of sets.
</strike>

**Exercise 2.60.** We specified that a set would be represented as a list with no
duplicates.  Now suppose we allow duplicates.  For instance,
the set {1,2,3} could be represented as the list <tt>(2 3 2 1 3 2
2)</tt>.  Design procedures <tt>element-of-set?</tt>, <tt>adjoin-set</tt>, <tt>union-set</tt>, and <tt>intersection-set</tt> that operate on this
representation.  How does the efficiency of each compare with the
corresponding procedure for the non-duplicate representation?  Are
there applications for which you would use this representation in
preference to the non-duplicate one?


<strike>**Exercise 2.61.** Give an implementation of <tt>adjoin-set</tt> using the ordered
representation.  By analogy with <tt>element-of-set?</tt></strike>

**Exercise 2.62.** Give a <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-3.gif' />(*n*) implementation of <tt>union-set</tt> for sets
represented as ordered lists.


<strike>**Exercise 2.63.** Each of the following two procedures converts a binary tree to a list.
</strike>

**Exercise 2.64.** The following procedure <tt>list-&gt;tree</tt> converts an ordered list to a
balanced binary tree.  The helper procedure <tt>partial-tree</tt> takes
as arguments an integer *n* and list of at least *n* elements and
constructs a balanced tree containing the first *n* elements of the
list.  The result returned by <tt>partial-tree</tt> is a pair (formed
with <tt>cons</tt>) whose <tt>car</tt> is the constructed tree and whose
<tt>cdr</tt> is the list of elements not included in the tree.

**Exercise 2.65.** Use the results of exercises 2.63 and
 2.64 to give <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-3.gif' />(*n*) implementations of <tt>union-set</tt> and <tt>intersection-set</tt> for sets implemented as
(balanced) binary trees.<sup><small>41</small></sup>

**Exercise 2.66.** Implement the <tt>lookup</tt>

<strike>**Exercise 2.67.** Define an encoding tree and a sample message:</strike>

<strike>**Exercise 2.68.** The <tt>encode</tt> procedure takes as arguments a message and a tree and
produces the list of bits that gives the encoded message.</strike>

**Exercise 2.69.** The following procedure takes as its argument a list of
symbol-frequency pairs (where no symbol appears in more than one pair)
and generates a Huffman encoding tree according to the Huffman
algorithm.

**Exercise 2.70.** The following eight-symbol alphabet with associated relative
frequencies was designed to efficiently encode the lyrics of 1950s
rock songs.  (Note that the ``symbols'' of an ``alphabet'' need not be
individual letters.)

**Exercise 2.71.** Suppose we have a Huffman tree for an alphabet of *n* symbols, and
that the relative frequencies of the symbols are 1, 2, 4, <tt>...</tt>,
2<sup><em>n</em>-1</sup>.  Sketch the tree for *n*=5; for *n*=10.  In such a tree
(for general *n*

**Exercise 2.72.** Consider the encoding procedure that you designed in
exercise 2.68.  What is the order of growth in the
number of steps needed to encode a symbol?  Be sure to include the
number of steps needed to search the symbol list at each node
encountered.  To answer this question in general is difficult.
Consider the special case where the relative frequencies of the *n*
symbols are as described in exercise 2.71, and give
the order of growth (as a function of *n*) of the number of steps
needed to encode the most frequent and least frequent symbols in the
alphabet.


<strike>**Exercise 2.73.** Section 2.3.2 described a program that
performs symbolic differentiation:
</strike>

**Exercise 2.74.** Insatiable Enterprises, Inc., is a highly decentralized conglomerate
company consisting of a large number of independent divisions located
all over the world.  The company's computer facilities have just been
interconnected by means of a clever network-interfacing scheme that
makes the entire network appear to any user to be a single computer.
Insatiable's president, in her first attempt to exploit the ability of
the network to extract administrative information from division files,
is dismayed to discover that, although all the division files have
been implemented as data structures in Scheme, the particular data
structure used varies from division to division.  A meeting of
division managers is hastily called to search for a strategy to
integrate the files that will satisfy headquarters' needs while
preserving the existing autonomy of the divisions.

<strike>**Exercise 2.75.** Implement the constructor <tt>make-from-mag-ang</tt> in message-passing style.
This procedure should be analogous to the <tt>make-from-real-imag</tt>
procedure given above.
</strike>

**Exercise 2.76.** As a large system with generic operations evolves, new types of data
objects or new operations may be needed.  For each of the three
strategies -- generic operations with explicit dispatch, data-directed
style, and message-passing-style -- describe the changes that must be
made to a system in order to add new types or new operations.  Which
organization would be most appropriate for a system in which new types
must often be added?  Which would be most appropriate for a system in
which new operations must often be added?


**Exercise 2.77.** Louis Reasoner tries to evaluate the
expression <tt>(magnitude z)</tt> where <tt>z</tt> is the object
shown in figure 2.24.  To his
surprise, instead of the answer 5
he gets an error message from <tt>apply-generic</tt>,
saying there is no method for the operation <tt>magnitude</tt>
on the types <tt>(complex)</tt>.
He shows this interaction to Alyssa P. Hacker, who says
``The problem is that the complex-number selectors were never
defined for <tt>complex</tt> numbers, just for <tt>polar</tt> and <tt>rectangular</tt>
numbers.  All you have to do to make this work is add the following
to the <tt>complex</tt> package:''

**Exercise 2.78.** The internal procedures in the <tt>scheme-number</tt> package are essentially
nothing more than calls to the primitive procedures <tt>+</tt>, <tt>-</tt>,
etc.  It was not possible to use the primitives of the language
directly because our type-tag system requires that each data
object have a type attached to it.  In fact, however, all Lisp
implementations do have a type system, which they use internally.
Primitive predicates such as <tt>symbol?</tt> and <tt>number?</tt>
determine whether data objects have particular types.  Modify the
definitions of <tt>type-tag</tt>, <tt>contents</tt>, and <tt>attach-tag</tt>
from section 2.4.2 so that our generic system takes
advantage of Scheme's internal type system.  That is to say, the system
should work as before except that ordinary numbers should be
represented simply as Scheme numbers rather than as pairs whose <tt>car</tt> is
the symbol <tt>scheme-number</tt>

**Exercise 2.79.** Define a generic equality predicate <tt>equ?</tt>

**Exercise 2.80.** Define a generic
predicate <tt>=zero?</tt>

**Exercise 2.81.** Louis Reasoner has noticed that <tt>apply-generic</tt> may try to
coerce the arguments to each other's type even if they already have
the same type.  Therefore, he reasons, we need to put procedures
in the coercion table to "coerce" arguments of each type to their
own type.  For example, in addition to the <tt>scheme-number-&gt;complex</tt>
coercion shown above, he would do:

**Exercise 2.82.** Show how to generalize <tt>apply-generic</tt>

**Exercise 2.83.** Suppose you are designing a generic arithmetic system for dealing with
the tower of types shown in figure 2.25:
integer, rational, real, complex.  For
each type (except complex), design a procedure that raises objects of
that type one level in the tower.  Show how to install a generic <tt>raise</tt>

**Exercise 2.84.** Using the <tt>raise</tt> operation of exercise 2.83, modify the <tt>apply-generic</tt>

**Exercise 2.85.** This section mentioned a method for ``simplifying'' a data object
by lowering it in the tower of types as far as possible.  Design
a procedure <tt>drop</tt> that accomplishes this for the tower described
in exercise 2.83.  The key is to decide, in some general way, whether
an object can be lowered.  For example, the complex number 1.5 + 0*i*
can be lowered as far as <tt>real</tt>, the complex number 1 + 0*i* can be
lowered as far as <tt>integer</tt>, and the complex number 2 + 3*i* cannot
be lowered at all.  Here is a plan for determining whether an object
can be lowered: Begin by defining a generic operation <tt>project</tt>
that ``pushes'' an object down in the tower.  For example, projecting
a complex number would involve throwing away the imaginary part.  Then
a number can be dropped if, when we <tt>project</tt> it and <tt>raise</tt>
the result back to the type we started with, we end up with something
equal to what we started with.  Show how to implement this idea in
detail, by writing a <tt>drop</tt> procedure that drops an object as far
as possible.  You will need to design the various projection
operations<sup><small>53</small></sup> and install <tt>project</tt> as a generic operation in
the system.  You will also need to make use of a generic equality
predicate, such as described in exercise 2.79.  Finally, use <tt>drop</tt>
to rewrite <tt>apply-generic</tt> from exercise 2.84

**Exercise 2.86.** Suppose we want to handle complex numbers whose real
parts, imaginary parts, magnitudes, and angles can be either ordinary
numbers, rational numbers, or other numbers we might wish to add to
the system.  Describe and implement the changes to the system needed
to accommodate this.  You will have to define operations such as <tt>sine</tt> and <tt>cosine</tt> that are generic over ordinary numbers and
rational numbers.


**Exercise 2.87.** Install <tt>=zero?</tt> for polynomials in the generic arithmetic
package.  This will allow <tt>adjoin-term</tt>

**Exercise 2.88.** 

**Exercise 2.89.** Define procedures that implement the term-list representation
described above as appropriate for dense polynomials.


**Exercise 2.90.** Suppose we want to have a polynomial system that is efficient for both
sparse and dense polynomials.  One way to do this is to allow both
kinds of term-list representations in our system.  The situation is
analogous to the complex-number example of section 2.4,
where we allowed both rectangular and polar representations.
To do this we must distinguish different types of term lists and make
the operations on term lists generic.  Redesign the polynomial system
to implement this generalization.  This is a major effort, not a local
change.


**Exercise 2.91.** A univariate polynomial can be divided by another one to produce a
polynomial quotient and a polynomial remainder.  For example,

**Exercise 2.92.** By imposing an ordering on variables, extend the polynomial package so
that addition and multiplication of polynomials works for polynomials
in different variables.  (This is not easy!)


**Exercise 2.93.** Modify the rational-arithmetic package to use generic operations, but
change <tt>make-rat</tt> so that it does not attempt to reduce fractions
to lowest terms.  Test your system by calling <tt>make-rational</tt> on
two polynomials to produce a rational function

**Exercise 2.94.** Using <tt>div-terms</tt>, implement the procedure <tt>remainder-terms</tt> and
use this to define <tt>gcd-terms</tt> as above.  Now write a procedure
<tt>gcd-poly</tt> that computes the polynomial GCD of two polys.
(The procedure should signal an error if the two polys are not
in the same variable.)  Install in the system a generic operation <tt>greatest-common-divisor</tt> that reduces to <tt>gcd-poly</tt> for polynomials
and to ordinary <tt>gcd</tt> for ordinary numbers.  As a test, try

**Exercise 2.95.** Define *P*<sub>1</sub>, *P*<sub>2</sub>, and *P*<sub>3</sub> to be the polynomials

**Exercise 2.96.** a. Implement the procedure <tt>pseudoremainder-terms</tt>, which is just like
<tt>remainder-terms</tt> except that it multiplies the dividend by
the integerizing factor described above before calling <tt>div-terms</tt>.
Modify <tt>gcd-terms</tt> to use <tt>pseudoremainder-terms</tt>, and verify
that <tt>greatest-common-divisor</tt> now produces an answer with integer
coefficients on the example in exercise 2.95.

**Exercise 2.97.** a. Implement this algorithm as a procedure <tt>reduce-terms</tt> that takes two
term lists <tt>n</tt> and <tt>d</tt> as arguments and returns a list <tt>nn</tt>, <tt>dd</tt>, which are <tt>n</tt> and <tt>d</tt> reduced to lowest terms
via the algorithm given above.
Also write a procedure <tt>reduce-poly</tt>, analogous to <tt>add-poly</tt>,
that checks to see if the two polys have
the same variable.  If so, <tt>reduce-poly</tt> strips off the variable and
passes the problem to <tt>reduce-terms</tt>, then reattaches the variable
to the two term lists supplied by <tt>reduce-terms</tt>.


## 3 Modularity, Objects, and State
<strike>**Exercise 3.1.** An *accumulator* is a procedure that is called repeatedly with a
single numeric argument and accumulates its arguments into a sum.
Each time it is called, it returns the currently accumulated sum.
Write a procedure <tt>make-accumulator</tt> that generates accumulators,
each maintaining an independent sum.  The input to <tt>make-accumulator</tt> should specify the initial value of the sum; for
example</strike>

<strike>**Exercise 3.2.** In software-testing applications, it is useful to be able to count the
number of times a given procedure is called during the course of a
computation.  Write a procedure <tt>make-monitored</tt> that takes as
input a procedure, <tt>f</tt>, that itself takes one input.  The result
returned by <tt>make-monitored</tt> is a third procedure, say <tt>mf</tt>,
that keeps track of the number of times it has been called by
maintaining an internal counter.  If the input to <tt>mf</tt> is the
special symbol <tt>how-many-calls?</tt>, then <tt>mf</tt> returns the
value of the counter.  If the input is the special symbol <tt>reset-count</tt>, then <tt>mf</tt> resets the counter to zero.  For any other
input, <tt>mf</tt> returns the result of calling <tt>f</tt> on that input
and increments the counter.  For instance, we could make a monitored
version of the <tt>sqrt</tt> procedure:</strike>

<strike>**Exercise 3.3.** Modify the <tt>make-account</tt> procedure so that it creates
password-protected accounts.  That is, <tt>make-account</tt> should take
a symbol as an additional argument, as in</strike>

<strike>**Exercise 3.4.** Modify the <tt>make-account</tt> procedure of
exercise 3.3 by adding another local state
variable so that, if an account is accessed more than seven
consecutive times with an incorrect password, it invokes the procedure
<tt>call-the-cops</tt>.
</strike>

**Exercise 3.5.** *Monte Carlo integration* is a method of estimating definite
integrals by means of Monte Carlo simulation.  Consider computing the
area of a region of space described by a predicate *P*(*x*, *y*) that is
true for points (*x*, *y*) in the region and false for points not in the
region.  For example, the region contained within a circle of radius
3 centered at (5, 7) is described by the predicate that tests
whether (*x* - 5)<sup>2</sup>  +  (*y* - 7)<sup>2</sup><u>&lt;</u> 3<sup>2</sup>.  To estimate the area of the
region described by such a predicate, begin by choosing a rectangle
that contains the region.  For example, a rectangle with diagonally
opposite corners at (2, 4) and (8, 10) contains the circle above.
The desired integral is the area of that portion of the rectangle that
lies in the region.  We can estimate the integral by picking, at
random, points (*x*,*y*) that lie in the rectangle, and testing *P*(*x*,
*y*) for each point to determine whether the point lies in the region.
If we try this with many points, then the fraction of points that fall
in the region should give an estimate of the proportion of the
rectangle that lies in the region.  Hence, multiplying this fraction
by the area of the entire rectangle should produce an estimate of the
integral.

<strike>**Exercise 3.6.** It is useful to be able to reset a random-number generator to produce
a sequence starting from a given value.  Design a new <tt>rand</tt>
procedure that is called with an argument that is either the symbol
<tt>generate</tt> or the symbol <tt>reset</tt> and behaves as follows: <tt>(rand
'generate)</tt> produces a new random number; <tt>((rand 'reset)
&lt;<em>new-value</em>&gt;)</tt> resets the internal state variable to the designated
&lt;*new-value*</strike>

**Exercise 3.7.** Consider the bank account objects created by <tt>make-account</tt>, with
the password modification described in
exercise 3.3.  Suppose that our banking
system requires the ability to make joint accounts.  Define a
procedure <tt>make-joint</tt> that accomplishes this.  <tt>Make-joint</tt>
should take three arguments.  The first is a password-protected
account.  The second argument must match the password with which the
account was defined in order for the <tt>make-joint</tt> operation to
proceed.  The third argument is a new password.  <tt>Make-joint</tt> is
to create an additional access to the original account using the new
password.  For example, if <tt>peter-acc</tt> is a bank account with
password <tt>open-sesame</tt>, then

**Exercise 3.8.** When we defined the evaluation model in
section 1.1.3, we said that the first step
in evaluating an expression is to evaluate its subexpressions.  But we
never specified the order in which the subexpressions should be
evaluated (e.g., left to right or right to left).  When we introduce
assignment, the order in which the arguments to a procedure are
evaluated can make a difference to the result.  Define a simple
procedure <tt>f</tt> such that evaluating <tt>(+ (f 0) (f 1))</tt> will
return 0 if the arguments to <tt>+</tt>

**Exercise 3.9.** In section 1.2.1
we used the substitution model to analyze two
procedures for computing factorials, a recursive version

**Exercise 3.10.** In the <tt>make-withdraw</tt> procedure, the local variable <tt>balance</tt>
is created as a parameter of <tt>make-withdraw</tt>.  We could also
create the local state variable explicitly, using <tt>let</tt>, as
follows:


**Exercise 3.11.** In section 3.2.3
we saw how the environment model described the
behavior of procedures with local state.  Now we have seen how
internal definitions work.  A typical message-passing procedure
contains both of these aspects.  Consider the bank account procedure
of section 3.1.1:

**Exercise 3.12.** The following procedure for appending lists was introduced in
section 2.2.1:

**Exercise 3.13.** Consider the following <tt>make-cycle</tt> procedure, which uses the <tt>last-pair</tt> procedure defined in exercise 3.12:

<strike>**Exercise 3.14.** The following procedure is quite useful, although obscure:</strike>

**Exercise 3.15.** Draw box-and-pointer diagrams to explain the effect of <tt>set-to-wow!</tt> on the structures <tt>z1</tt> and <tt>z2</tt> above.


**Exercise 3.16.** Ben Bitdiddle decides to write a procedure to count the number of
pairs in any list structure.  ``It's easy,'' he reasons.  ``The number
of pairs in any structure is the number in the <tt>car</tt> plus the
number in the <tt>cdr</tt> plus one more to count the current pair.''
So Ben writes the following procedure:

<strike>**Exercise 3.17.** Devise a correct version of the <tt>count-pairs</tt> procedure of
exercise 3.16 that returns the number of distinct
pairs in any structure.  (Hint: Traverse the structure, maintaining an
auxiliary data structure that is used to keep track of which pairs
have already been counted.)
</strike>

<strike>**Exercise 3.18.** Write a procedure that examines a list and determines whether it
contains a cycle, that is, whether a program that tried to find the
end of the list by taking successive <tt>cdr</tt>s would go into an
infinite loop.  Exercise 3.13</strike>

<strike>**Exercise 3.19.** Redo exercise 3.18 using an algorithm that takes only a
constant amount of space.  (This requires a very clever idea.)
</strike>

**Exercise 3.20.** Draw environment diagrams to illustrate the evaluation of the sequence
of expressions

<strike>**Exercise 3.21.** Ben Bitdiddle decides to test the queue implementation described
above.  He types in the procedures to the Lisp interpreter and
proceeds to try them out:</strike>

<strike>**Exercise 3.22.** Instead of representing a queue as a pair of pointers, we can build a
queue as a procedure with local state.  The local state will consist
of pointers to the beginning and the end of an ordinary list.  Thus,
the <tt>make-queue</tt> procedure will have the form</strike>

**Exercise 3.23.** A *deque* (``double-ended queue'') is a sequence in which items
can be inserted and deleted at either the front or the rear.
Operations on deques are the constructor <tt>make-deque</tt>, the predicate <tt>empty-deque?</tt>, selectors <tt>front-deque</tt> and <tt>rear-deque</tt>, and mutators <tt>front-insert-deque!</tt>, <tt>rear-insert-deque!</tt>, <tt>front-delete-deque!</tt>, and <tt>rear-delete-deque!</tt>.  Show how to represent deques using pairs, and
give implementations of the operations.<sup><small>23</small></sup>
All operations should be accomplished in <img src='http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-3.gif' />(1) steps.


<strike>**Exercise 3.24.** In the table implementations above, the keys are tested for equality
using <tt>equal?</tt> (called by <tt>assoc</tt>).  This is not always the appropriate test.  For
instance, we might have a table with numeric keys in which we don't
need an exact match to the number we're looking up,
but only a number within some tolerance of it.
Design a table constructor <tt>make-table</tt> that takes as an argument a <tt>same-key?</tt> procedure
that will be used to test ``equality'' of keys.  <tt>Make-table</tt> should
return a <tt>dispatch</tt> procedure that can be used to access
appropriate <tt>lookup</tt> and <tt>insert!</tt></strike>

<strike>**Exercise 3.25.** Generalizing one- and two-dimensional tables, show how to implement a
table in which values are stored under an arbitrary number of keys and
different values may be stored under different numbers of keys.  The
<tt>lookup</tt> and <tt>insert!</tt> procedures should take as input a list
of keys used to access the table.
</strike>

**Exercise 3.26.** To search a table as implemented above, one needs to scan through the
list of records.  This is basically the unordered list representation of
section 2.3.3.  For large tables, it may be more
efficient to structure the table in a different manner.  Describe a
table implementation where the (key, value) records are organized
using a binary tree, assuming that keys can be ordered in some way
(e.g., numerically or alphabetically).  (Compare
exercise 2.66 of chapter 2.)


**Exercise 3.27.** *Memoization* (also called *tabulation*) is a technique that
enables a procedure to record, in a local table, values that have
previously been computed.  This technique can make a vast difference
in the performance of a program.  A memoized procedure maintains a
table in which values of previous calls are stored
using as keys the arguments that produced the values.  When the
memoized procedure is asked to compute a value, it first checks the
table to see if the value is already there and, if so, just returns
that value.  Otherwise, it computes the new value in the ordinary way
and stores this in the table.  As an example of memoization, recall
from section 1.2.2 the exponential process for
computing Fibonacci numbers:

<strike>**Exercise 3.28.** Define an or-gate as a primitive function box.  Your <tt>or-gate</tt>
constructor should be similar to <tt>and-gate</tt>.
</strike>

<strike>**Exercise 3.29.** Another way to construct an or-gate is as a compound digital logic
device, built from and-gates and inverters.  Define a procedure <tt>or-gate</tt> that accomplishes this.  What is the delay time of the
or-gate in terms of <tt>and-gate-delay</tt> and <tt>inverter-delay</tt>?
</strike>

**Exercise 3.30.** Figure 3.27 shows a *ripple-carry adder* formed by stringing
together *n* full-adders.  This is the simplest form of parallel adder
for adding two *n*-bit binary numbers.  The inputs A<sub>1</sub>, A<sub>2</sub>,
A<sub>3</sub>, <tt>...</tt>, A<sub><em>n</em></sub> and B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, <tt>...</tt>,
B<sub><em>n</em></sub> are the two binary numbers to be added (each A<sub><em>k</em></sub> and B<sub><em>k</em></sub>
is a 0 or a 1).  The circuit generates S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>,
<tt>...</tt>, S<sub><em>n</em></sub>, the *n* bits of the sum, and C, the carry from
the addition.  Write a procedure <tt>ripple-carry-adder</tt> that
generates this circuit.  The procedure should take as arguments three
lists of *n* wires each -- the A<sub><em>k</em></sub>, the B<sub><em>k</em></sub>, and the S<sub><em>k</em></sub> -- and
also another wire C.  The major drawback of the ripple-carry adder is
the need to wait for the carry signals to propagate.  What is the
delay needed to obtain the complete output from an *n*

**Exercise 3.31.** 
The internal procedure <tt>accept-action-procedure!</tt> defined in <tt>make-wire</tt> specifies that when a new action procedure is added to
a wire, the procedure is immediately run.  Explain why this initialization
is necessary.  In particular, trace through the half-adder example in
the paragraphs above and say how the system's response would differ if
we had defined <tt>accept-action-procedure!</tt> as

**Exercise 3.32.**

**Exercise 3.33.** Using primitive multiplier, adder, and constant constraints, define a
procedure <tt>averager</tt> that takes three connectors <tt>a</tt>, <tt>b</tt>,
and <tt>c</tt> as inputs and establishes the constraint that the value of
<tt>c</tt> is the average of the values of <tt>a</tt> and <tt>b</tt>.


**Exercise 3.34.** Louis Reasoner wants to build a squarer, a constraint device with two
terminals such that the value of connector <tt>b</tt> on the second
terminal will always be the square of the value <tt>a</tt> on the first
terminal.  He proposes the following simple device made from a
multiplier:

**Exercise 3.35.** Ben Bitdiddle tells Louis that one way to avoid the trouble in
exercise 3.34 is to define a squarer as a new
primitive constraint.  Fill in the missing portions in Ben's outline
for a procedure to implement such a constraint:

**Exercise 3.36.** Suppose we evaluate the following sequence of expressions in the
global environment:

**Exercise 3.37.** The <tt>celsius-fahrenheit-converter</tt> procedure is cumbersome when
compared with a more expression-oriented style of definition, such as

**Exercise 3.38.** Suppose that Peter, Paul, and Mary share a joint bank account that
initially contains $100.  Concurrently, Peter deposits $10, Paul
withdraws $20, and Mary withdraws half the money in the account, by
executing the following commands:


**Exercise 3.39.** Which of the five possibilities in the parallel execution shown above
remain if we instead serialize execution as follows:

**Exercise 3.40.** Give all possible values of <tt>x</tt> that can result from executing

**Exercise 3.41.** Ben Bitdiddle worries that it would be better to implement the bank
account as follows (where the commented line has been changed):

**Exercise 3.42.** Ben Bitdiddle suggests that it's a waste of time to create a new
serialized procedure in response to every <tt>withdraw</tt> and <tt>deposit</tt> message.  He says that <tt>make-account</tt> could be changed so
that the calls to <tt>protected</tt> are done outside the <tt>dispatch</tt>
procedure.  That is, an account would return the same serialized
procedure (which was created at the same time as the account) each time
it is asked for a withdrawal procedure.


**Exercise 3.43.** Suppose that the balances in three accounts start out as $10, $20,
and $30, and that multiple processes run, exchanging the balances in
the accounts.  Argue that if the processes are run sequentially,
after any number of concurrent exchanges, the account balances should be 
$10, $20, and $30 in some order.
Draw a timing diagram like the one in figure 3.29 to
show how this condition can be violated if the exchanges are
implemented using the first version of the account-exchange program in
this section.  On the other hand, argue that even with this <tt>exchange</tt>

**Exercise 3.44.** Consider the problem of transferring an amount from one account to
another.  Ben Bitdiddle claims that this can be accomplished with the
following procedure, even if there are multiple people concurrently
transferring money among multiple accounts, using any account
mechanism that serializes deposit and withdrawal transactions, for
example, the version of <tt>make-account</tt> in the text above.

**Exercise 3.45.** Louis Reasoner thinks our bank-account system is unnecessarily complex and
error-prone now that deposits and withdrawals aren't automatically serialized.
He suggests that <tt>make-account-and-serializer</tt> should have
exported the serializer (for use by such procedures as
<tt>serialized-exchange</tt>) in addition to (rather than instead of)
using it to serialize accounts and deposits as <tt>make-account</tt> did.
He proposes to redefine accounts as follows:

**Exercise 3.46.** Suppose that we implement <tt>test-and-set!</tt>  using an ordinary
procedure as shown in the text, without attempting to make the operation
atomic.  Draw a timing diagram like the one in
figure 3.29

**Exercise 3.47.** A semaphore (of size *n*) is a generalization of a mutex.  Like a
mutex, a semaphore supports acquire and release operations, but it is
more general in that up to *n* processes can acquire it
concurrently.  Additional processes that attempt to acquire the
semaphore must wait for release operations.  Give implementations of
semaphores

**Exercise 3.48.** Explain in detail why the deadlock-avoidance method described above,
(i.e., the accounts are numbered, and each process attempts to acquire
the smaller-numbered account first) avoids deadlock in the exchange
problem.  Rewrite <tt>serialized-exchange</tt> to incorporate this idea.
(You will
also need to modify <tt>make-account</tt>

**Exercise 3.49.**

**Exercise 3.50.** Complete the following definition, which
generalizes <tt>stream-map</tt> to allow procedures that
take multiple arguments, analogous to <tt>map</tt> in
section 2.2.3, footnote 12.

**Exercise 3.51.** In order to take a closer look at delayed evaluation, we will use the
following procedure, which simply returns its argument after printing it:

**Exercise 3.52.** Consider the sequence of expressions

**Exercise 3.53.** Without running the program, describe the elements of the
stream defined by


**Exercise 3.54.** Define a procedure <tt>mul-streams</tt>, analogous to <tt>add-streams</tt>,
that produces the elementwise product of its two input streams.
Use this together with the stream of <tt>integers</tt> to complete the
following definition of the stream whose *n*th element (counting from 0)
is *n*

**Exercise 3.55.** Define a procedure <tt>partial-sums</tt> that takes as argument a
stream *S* and returns the stream whose
elements are *S*<sub>0</sub>, *S*<sub>0</sub> + *S*<sub>1</sub>, *S*<sub>0</sub> + *S*<sub>1</sub> + *S*<sub>2</sub>, <tt>...</tt>.  For example, <tt>(partial-sums integers)</tt> should be the stream
1, 3, 6, 10, 15, <tt>...</tt>

**Exercise 3.56.** A famous problem, first raised by R. Hamming, is to enumerate, in
ascending order with no repetitions, all positive integers with no
prime factors other than 2, 3, or 5.  One obvious way to do this is to
simply test each integer in turn to see whether it has any factors
other than 2, 3, and 5.  But this is very inefficient, since, as the
integers get larger, fewer and fewer of them fit the requirement.  As
an alternative, let us call the required stream of numbers <tt>S</tt> and
notice the following facts about it.


**Exercise 3.57.** How many additions are performed when we compute the *n*th Fibonacci
number using the definition of <tt>fibs</tt> based on the <tt>add-streams</tt> procedure?  Show that the number of additions would be
exponentially greater if we had implemented
<tt>(delay &lt;<em>exp</em>&gt;)</tt> simply as <tt>(lambda () &lt;<em>exp</em>&gt;)</tt>, 
without using the optimization provided by the <tt>memo-proc</tt>
procedure described in section 3.5.1.<sup><small>64</small></sup>

**Exercise 3.58.** Give an interpretation of the stream computed by the following
procedure:

**Exercise 3.59.** In section 2.5.3 we saw how to implement a
polynomial arithmetic system representing polynomials as lists of
terms.  In a similar way, we can work with *power series*, such as

**Exercise 3.60.** With power series represented as streams of coefficients as in
exercise 3.59, adding series is implemented by <tt>add-streams</tt>.  Complete the definition of the following procedure for
multiplying series:


**Exercise 3.61.** Let *S* be a power series (exercise 3.59)
whose constant term is 1.  Suppose we want
to find the power series 1/*S*, that is, the series *X* such that
*S* &middot;  *X* =  1.  Write *S* = 1 + *S*<sub><em>R</em></sub> where *S*<sub><em>R</em></sub> is the part of *S* after
the constant term.  Then we can solve for *X* as follows:


**Exercise 3.62.** Use the results of exercises 3.60
and 3.61 to define a procedure <tt>div-series</tt>
that divides two power series.  <tt>Div-series</tt> should work for any
two series, provided that the denominator series begins with a
nonzero constant term.  (If the denominator has a zero constant term,
then <tt>div-series</tt> should signal an error.)
Show how to use <tt>div-series</tt>
together with the result of exercise 3.59 to generate
the power series for tangent.


**Exercise 3.63.** Louis Reasoner asks why the <tt>sqrt-stream</tt> procedure was not
written in the following more straightforward way, without
the local variable <tt>guesses</tt>:


**Exercise 3.64.** Write a procedure <tt>stream-limit</tt> that takes as arguments a stream
and a number (the tolerance).  It should examine the stream until it
finds two successive elements that differ in absolute value by less
than the tolerance, and return the second of the two elements.  Using
this, we could compute square roots up to a given tolerance by


**Exercise 3.65.** Use the series


**Exercise 3.66.** Examine the stream <tt>(pairs integers integers)</tt>. Can you make any general
comments about the order in which the pairs are placed into the
stream? For example, about how many pairs precede the pair (1,100)?
the pair (99,100)? the pair (100,100)? (If you can make precise
mathematical statements here, all the better. But feel free to give
more qualitative answers if you find yourself getting bogged down.)


**Exercise 3.67.** Modify the <tt>pairs</tt> procedure so that <tt>(pairs integers
integers)</tt> will produce the stream of *all* pairs of integers
(*i*,*j*) (without the condition *i* <u>&lt;</u> *j*).  Hint: You will need to
mix in an additional stream.


**Exercise 3.68.** Louis Reasoner thinks that building a stream of pairs from three
parts is unnecessarily complicated.  Instead of separating the
pair (*S*<sub>0</sub>,*T*<sub>0</sub>) from the rest of the pairs in the first row,
he proposes to work with the whole first row, as follows:


**Exercise 3.69.** Write a procedure <tt>triples</tt> that takes three infinite
streams, *S*, *T*, and *U*, and produces the stream of triples
(*S*<sub><em>i</em></sub>,*T*<sub><em>j</em></sub>,*U*<sub><em>k</em></sub>) such that *i* <u>&lt;</u> *j* <u>&lt;</u> *k*.
Use <tt>triples</tt> to
generate the stream of all Pythagorean triples of positive integers,
i.e., the triples (*i*,*j*,*k*) such that *i* <u>&lt;</u> *j* and *i*<sup>2</sup>  +  *j*<sup>2</sup>  = *k*<sup>2</sup>

**Exercise 3.70.** It would be nice to be able to generate streams in which the pairs
appear in some useful order, rather than in the order that results
from an *ad hoc* interleaving process.  We can use a technique
similar to the <tt>merge</tt> procedure of exercise 3.56, if we
define a way to say that one pair of integers is ``less than''
another.  One way to do this is to define a ``weighting function''
*W*(*i*,*j*) and stipulate that (*i*<sub>1</sub>,*j*<sub>1</sub>) is less than (*i*<sub>2</sub>,*j*<sub>2</sub>) if
*W*(*i*<sub>1</sub>,*j*<sub>1</sub>) &lt; *W*(*i*<sub>2</sub>,*j*<sub>2</sub>).  Write a procedure <tt>merge-weighted</tt>
that is like <tt>merge</tt>, except that <tt>merge-weighted</tt> takes an
additional argument <tt>weight</tt>, which is a procedure that computes
the weight of a pair, and is used to determine the order in which
elements should appear in the resulting merged stream.<sup><small>69</small></sup>
Using this,
generalize <tt>pairs</tt> to a procedure <tt>weighted-pairs</tt> that
takes two streams, together with a procedure that computes a weighting
function, and generates the stream of pairs, ordered according to
weight.  Use your procedure to generate

**Exercise 3.71.** Numbers that can be expressed as the sum of two cubes in more than one
way are sometimes called *Ramanujan numbers*, in honor of the
mathematician Srinivasa Ramanujan.<sup><small>70</small></sup>
Ordered streams of pairs provide an elegant solution to the problem of
computing these numbers.  To find a number that can be written as the
sum of two cubes in two different ways, we need only generate the
stream of pairs of integers (*i*,*j*) weighted according to the sum *i*<sup>3</sup>
 +  *j*<sup>3</sup> (see exercise 3.70

**Exercise 3.72.** In a similar way to exercise 3.71 generate
a stream of
all numbers that can be written as the sum of two squares in three
different ways (showing how they can be so written).


**Exercise 3.73.** 

**Exercise 3.74.** Alyssa P. Hacker is designing a system to process signals coming from
physical sensors.  One important feature she wishes to produce is a
signal that describes the *zero crossings* of the input signal.
That is, the resulting signal should be  + 1 whenever the input signal
changes from negative to positive,  - 1 whenever the input signal
changes from positive to negative, and 0 otherwise.  (Assume that the
sign of a 0 input is positive.)  For example, a typical input signal
with its associated zero-crossing signal would be


**Exercise 3.75.** Unfortunately, Alyssa's zero-crossing detector in
exercise 3.74 proves to be insufficient, because the
noisy signal from the sensor leads to spurious zero crossings.  Lem E.
Tweakit, a hardware specialist, suggests that Alyssa smooth the signal
to filter out the noise before extracting the zero crossings.  Alyssa
takes his advice and decides to extract the zero crossings from the
signal constructed by averaging each value of the sense data with the
previous value.  She explains the problem to her assistant, Louis
Reasoner, who attempts to implement the idea, altering Alyssa's program as
follows:

**Exercise 3.76.** Eva Lu Ator has a criticism of Louis's approach in
exercise 3.75.  The program he wrote is not modular,
because it intermixes the operation of smoothing with the
zero-crossing extraction.  For example, the extractor should not have
to be changed if Alyssa finds a better way to condition her input
signal.  Help Louis by writing a procedure <tt>smooth</tt> that takes a
stream as input and produces a stream in which each element is the
average of two successive input stream elements.  Then use <tt>smooth</tt> as a component to implement the zero-crossing detector in a
more modular style.


**Exercise 3.77.** The <tt>integral</tt> procedure used above was analogous to the
``implicit'' definition of the infinite stream of integers in
section 3.5.2.  Alternatively, we can give a
definition of <tt>integral</tt> that is more like <tt>integers-starting-from</tt> (also in section 3.5.2):

**Exercise 3.78.** 

**Exercise 3.79.** Generalize the <tt>solve-2nd</tt> procedure of exercise 3.78 so
that it can be used to solve general second-order differential
equations *d*<sup>2</sup>*y*/*d**t*<sup>2</sup> = *f*(*d**y*/*d**t*,  *y*).


**Exercise 3.80.** A *series RLC circuit* consists of a resistor, a capacitor, and an
inductor connected in series, as shown in figure 3.36.
If *R*, *L*, and *C* are the resistance, inductance, and capacitance,
then the relations between voltage (*v*) and current (*i*)
for the three components are described by the equations


**Exercise 3.81.** Exercise 3.6
discussed generalizing the random-number generator to
allow one to reset the random-number sequence so as to produce
repeatable sequences of ``random'' numbers.  Produce a stream
formulation of this same generator that operates on an input stream of
requests to <tt>generate</tt> a new random number or to <tt>reset</tt> the
sequence to a specified value and that produces the desired stream of
random numbers.  Don't use assignment in your solution.


**Exercise 3.82.** Redo exercise 3.5 on Monte Carlo
integration in terms of streams.  The stream version of <tt>estimate-integral</tt> will not have an argument telling how many trials
to perform.  Instead, it will produce a stream of estimates based on
successively more trials.


## 4 Metalinguistic Abstraction
<strike>**Exercise 4.1.** Notice that we cannot tell whether the metacircular evaluator
evaluates operands from left to right or from right to left.  Its evaluation
order is inherited from the underlying Lisp:
If the arguments to <tt>cons</tt> in <tt>list-of-values</tt>
are evaluated from left to right, then <tt>list-of-values</tt> will
evaluate operands from left to right; and 
if the arguments to <tt>cons</tt>
are evaluated from right to left, then <tt>list-of-values</tt> will
evaluate operands from right to left.</strike>

**Exercise 4.2.** Louis Reasoner plans to reorder the <tt>cond</tt> clauses
in <tt>eval</tt> so that the clause for procedure applications appears
before the clause for assignments.  He argues that this will make the
interpreter more efficient:  Since programs usually contain more
applications than assignments, definitions, and so on,
his modified <tt>eval</tt> will usually check fewer
clauses than the original <tt>eval</tt> before identifying the type of an
expression.

**Exercise 4.3.** Rewrite <tt>eval</tt> so that the dispatch is done in data-directed
style.  Compare this with the data-directed
differentiation procedure of
exercise 2.73.
(You may use the <tt>car</tt> of a compound expression as the
type of the expression, as is appropriate for the syntax implemented
in this section.)
.


<strike>**Exercise 4.4.** Recall the definitions of the special forms <tt>and</tt> and <tt>or</tt>
from chapter 1:
</strike>

<strike>**Exercise 4.5.** Scheme allows an additional syntax for <tt>cond</tt> clauses, <tt>(&lt;<em>test</em>&gt; =&gt; &lt;<em>recipient</em>&gt;)</tt>.  If &lt;*test*&gt;
evaluates to a true value, then &lt;*recipient*&gt; is evaluated.  Its
value must be a procedure of one argument; this procedure is then
invoked on the value of the &lt;*test*&gt;, and the result is returned as
the value of the <tt>cond</tt> expression.  For example</strike>

<strike>**Exercise 4.6.** <tt>Let</tt> expressions are derived expressions, because</strike>

<strike>**Exercise 4.7.** <tt>Let*</tt> is similar to <tt>let</tt>, except that the bindings of the <tt>let</tt> variables are performed sequentially from left to right, and each
binding is made in an environment in which all of the preceding
bindings are visible.  For example
</strike>

**Exercise 4.8.** ``Named <tt>let</tt>'' is a variant of <tt>let</tt> that has the form


**Exercise 4.9.** Many languages support a variety of iteration constructs, such as <tt>do</tt>, <tt>for</tt>, <tt>while</tt>, and <tt>until</tt>.  In Scheme,
iterative processes can be expressed in terms of ordinary procedure
calls, so special iteration constructs provide no essential gain in
computational power.  On the other hand, such constructs are often
convenient.  Design some iteration constructs, give examples of their
use, and show how to implement them as derived expressions.


**Exercise 4.10.** By using data abstraction, we were able to write an <tt>eval</tt>
procedure that is independent of the particular syntax of the language
to be evaluated.  To illustrate this, design and implement a new
syntax for Scheme by modifying the procedures in this section, without
changing <tt>eval</tt> or <tt>apply</tt>.


<strike>**Exercise 4.11.**</strike>

<strike>**Exercise 4.12.** The procedures <tt>set-variable-value!</tt>, <tt>define-variable!</tt>,
and <tt>lookup-variable-value</tt> can be expressed in terms of
more abstract procedures for traversing the environment structure.
Define abstractions that capture the common patterns and redefine
the three procedures in terms of these abstractions.
</strike>

<strike>**Exercise 4.13.** Scheme allows us to create new bindings for variables by means of <tt>define</tt>, but provides no way to get rid of bindings.  Implement for
the evaluator a special form <tt>make-unbound!</tt> that removes the
binding of a given symbol from the environment in which the
<tt>make-unbound!</tt> expression is evaluated.
This problem is not completely specified.  For example,
should we remove only the binding in the first frame of the
environment?  Complete the specification and justify any choices you
make.
</strike>

**Exercise 4.14.** Eva Lu Ator and Louis Reasoner are each experimenting with the
metacircular evaluator.  Eva types in the definition of <tt>map</tt>, and
runs some test programs that use it.  They work fine.  Louis, in contrast,
has installed the system version of <tt>map</tt> as a primitive for the
metacircular evaluator.  When he tries it, things go terribly
wrong.  Explain why Louis's <tt>map</tt> fails even though Eva's works.


<strike>**Exercise 4.15.** Given a one-argument procedure <tt>p</tt> and an object <tt>a</tt>, <tt>p</tt>
is said to ``halt'' on <tt>a</tt> if evaluating the expression <tt>(p
a)</tt> returns a value (as opposed to terminating with an error message
or running forever).  Show that it is impossible to write a procedure
<tt>halts?</tt> that correctly determines whether <tt>p</tt> halts on <tt>a</tt> for any procedure <tt>p</tt> and object <tt>a</tt>.  Use the following
reasoning: If you had such a procedure <tt>halts?</tt>, you could
implement the following program:
</strike>

<strike>**Exercise 4.16.** In this exercise we implement the method just described for
interpreting internal definitions.
We assume that the evaluator supports <tt>let</tt>
(see exercise 4.6).</strike>

**Exercise 4.17.** Draw diagrams of the environment in effect when evaluating the
expression &lt;*e3*&gt; in the procedure in the text, comparing how this
will be structured when definitions are interpreted sequentially with
how it will be structured if definitions are scanned out as described.
Why is there an extra frame in the transformed program?  Explain why
this difference in environment structure can never make a difference
in the behavior of a correct program.  Design a way to make the
interpreter implement the ``simultaneous'' scope rule for internal
definitions without constructing the extra frame.


**Exercise 4.18.** Consider an alternative strategy for scanning out definitions that
translates the example in the text to


**Exercise 4.19.** Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about
the desired result of evaluating the expression

**Exercise 4.20.** Because internal definitions look sequential but are actually
simultaneous, some people prefer to avoid them entirely, and use the
special form <tt>letrec</tt> instead.  <tt>Letrec</tt> looks like <tt>let</tt>,
so it is not surprising that the variables it binds are bound
simultaneously and have the same scope as each other.  The sample
procedure <tt>f</tt> above can be written without internal definitions,
but with exactly the same meaning, as

<strike>**Exercise 4.21.** Amazingly, Louis's intuition in exercise 4.20
is correct.  It is indeed possible to specify recursive procedures
without using <tt>letrec</tt> (or even <tt>define</tt>), although the method
for accomplishing this is much more subtle than Louis imagined.  The
following expression computes 10 factorial by applying a recursive
factorial procedure:<sup><small>27</small></sup></strike>

**Exercise 4.22.** Extend the evaluator in this section to support the special form <tt>let</tt>.
(See exercise 4.6

**Exercise 4.23.** Alyssa P. Hacker doesn't understand why <tt>analyze-sequence</tt> needs to be
so complicated.  All the other analysis procedures
are straightforward transformations of the corresponding evaluation
procedures (or <tt>eval</tt> clauses) in section 4.1.1.
She expected <tt>analyze-sequence</tt> to look like this:

**Exercise 4.24.** Design and carry out some experiments to 
compare the speed of the original metacircular evaluator
with the version in this section.  Use your results to estimate the fraction
of time that is spent in analysis versus execution for various
procedures.


<strike>**Exercise 4.25.** Suppose that (in ordinary applicative-order Scheme) we define <tt>unless</tt>
as shown above and then define <tt>factorial</tt> in terms of <tt>unless</tt> as</strike>

**Exercise 4.26.** Ben Bitdiddle and Alyssa P. Hacker disagree over the importance of
lazy evaluation for implementing things such as <tt>unless</tt>.  Ben
points out that it's possible to implement <tt>unless</tt> in applicative
order as a special form.
Alyssa counters that, if one did that, <tt>unless</tt> would be merely
syntax, not a procedure that could be used in conjunction with
higher-order procedures.  Fill in the details on both sides of the
argument.  Show how to implement <tt>unless</tt> as a derived expression
(like <tt>cond</tt> or <tt>let</tt>),
and give an example of a situation where it might be useful to have
<tt>unless</tt>

**Exercise 4.27.** Suppose we type in the following definitions to the lazy evaluator:


**Exercise 4.28.** <tt>Eval</tt> uses <tt>actual-value</tt> rather than <tt>eval</tt>
to evaluate the operator before passing it to <tt>apply</tt>,
in order to force the value of the operator.
Give an example that demonstrates the need for this forcing.


**Exercise 4.29.** Exhibit a program that you would expect to run much more slowly
without memoization than with memoization.  Also, consider the
following interaction, where the <tt>id</tt> procedure is defined as in
exercise 4.27 and <tt>count</tt> starts at 0:


**Exercise 4.30.** Cy D. Fect, a reformed C programmer, is worried that some side effects
may never take place, because the lazy evaluator doesn't force the
expressions in a sequence.
Since the value of an expression in a sequence other than the last one
is not used (the expression is there only for its effect, such as
assigning to a variable or printing), there can be no subsequent use
of this value (e.g., as an argument to a primitive procedure) that
will cause it to be forced.  Cy thus thinks that when evaluating
sequences, we must force all expressions in the sequence except the
final one.  He proposes to modify <tt>eval-sequence</tt> from
section 4.1.1 to use <tt>actual-value</tt> rather
than <tt>eval</tt>:

**Exercise 4.31.** The approach taken in this section is somewhat unpleasant, because it
makes an incompatible change to Scheme.  It might be nicer to
implement lazy evaluation as an *upward-compatible extension*,
that is, so that ordinary Scheme programs will work as before.  We can
do this by extending the syntax of procedure declarations to let the user
control whether or not arguments are to be delayed.  While we're at
it, we may as well also give the user the choice between delaying with
and without memoization.  For example, the definition


**Exercise 4.32.** Give some examples that illustrate the difference between the streams
of chapter 3 and the ``lazier'' lazy lists described in this section.
How can you take advantage of this extra laziness?


**Exercise 4.33.** Ben Bitdiddle tests the lazy list implementation given above by
evaluating the expression


**Exercise 4.34.**

**Exercise 4.35.** Write a procedure <tt>an-integer-between</tt> that returns an integer
between two given bounds.  This can be used to implement a
procedure that finds Pythagorean triples,
i.e., triples of integers (*i*,*j*,*k*) between the given bounds such
that *i* <u>&lt;</u> *j* and *i*<sup>2</sup>  +  *j*<sup>2</sup>  = *k*<sup>2</sup>, as follows:


**Exercise 4.36.** Exercise 3.69 discussed how to generate
the stream of *all* Pythagorean triples, with no upper bound on the
size of the integers to be searched.  Explain why simply replacing
<tt>an-integer-between</tt> by <tt>an-integer-starting-from</tt> in the procedure in
exercise 4.35 is not an adequate way to
generate arbitrary Pythagorean triples.  Write a procedure that
actually will accomplish this.  (That is, write a procedure for which
repeatedly typing <tt>try-again</tt> would in principle eventually
generate all Pythagorean triples.)


**Exercise 4.37.** Ben Bitdiddle claims that the following method for generating
Pythagorean triples is more efficient than the one in
exercise 4.35.  Is he correct?  (Hint: Consider
the number of possibilities that must be explored.)

**Exercise 4.38.** Modify the multiple-dwelling procedure to omit the requirement that
Smith and Fletcher do not live on adjacent floors.  How many solutions
are there to this modified puzzle?


**Exercise 4.39.**

**Exercise 4.40.** In the multiple dwelling problem, how many sets of assignments are
there of people to floors, both before and after the requirement that
floor assignments be distinct?  It is very inefficient to generate all
possible assignments of people to floors and then leave it to
backtracking to eliminate them.  For example, most of the restrictions
depend on only one or two of the person-floor variables, and can thus
be imposed before floors have been selected for all the people.
Write and demonstrate a much more efficient
nondeterministic procedure that solves this problem based upon
generating only those possibilities that are not already ruled out by
previous restrictions.  (Hint: This will require a nest of <tt>let</tt>

**Exercise 4.41.** Write an ordinary Scheme program to solve the multiple dwelling puzzle.


**Exercise 4.42.** Solve the following ``Liars'' puzzle (from Phillips 1934):


**Exercise 4.43.** Use the <tt>amb</tt> evaluator to solve the following puzzle:<sup><small>49</small></sup>

**Exercise 4.44.** Exercise 2.42 described the ``eight-queens puzzle'' of
placing queens on a chessboard so that no two attack each other.
Write a nondeterministic program to solve this puzzle.


**Exercise 4.45.** With the grammar given above, the following sentence can be parsed in
five different ways:
``The professor lectures to the student in the class with the cat.''
Give the five parses and explain the differences in shades of
meaning among them.


**Exercise 4.46.** The evaluators in sections 4.1 and 4.2
do not determine what order operands are evaluated in.
We will see that the <tt>amb</tt> evaluator evaluates them from left to right.
Explain why our parsing program wouldn't work if the operands were evaluated
in some other order.


**Exercise 4.47.** Louis Reasoner suggests that, since a verb phrase is either a verb or
a verb phrase followed by a prepositional phrase, it would be much more
straightforward to define the procedure <tt>parse-verb-phrase</tt> as
follows (and similarly for noun phrases):


**Exercise 4.48.** Extend the grammar given above to handle more complex sentences.  For
example, you could extend noun phrases and verb phrases to include
adjectives and adverbs, or you could handle compound sentences.<sup><small>53</small></sup>

**Exercise 4.49.** Alyssa P. Hacker is more interested in generating interesting
sentences than in parsing them.  She reasons that by simply changing
the procedure <tt>parse-word</tt> so that it ignores the ``input
sentence'' and instead always succeeds and generates an appropriate
word, we can use the programs we had built for parsing to do
generation instead.  Implement Alyssa's idea, and show the first
half-dozen or so sentences generated.<sup><small>54</small></sup>

**Exercise 4.50.** Implement a new special form <tt>ramb</tt> that is like <tt>amb</tt> except that it searches alternatives in a random order, rather 
than from left to right.  Show how this can help with Alyssa's problem
in exercise 4.49

**Exercise 4.51.** Implement a new kind of assignment called <tt>permanent-set!</tt> that
is not undone upon failure.  For example, we can choose two distinct
elements from a list and count the number of trials required to make a
successful choice as follows:

**Exercise 4.52.** Implement a new construct called <tt>if-fail</tt> that permits the user to
catch the failure of an expression.  <tt>If-fail</tt> takes two
expressions.  It evaluates the first expression as usual and returns
as usual if the evaluation succeeds.  If the evaluation fails,
however, the value of the second expression is returned, as in the
following example:


**Exercise 4.53.** With <tt>permanent-set!</tt> as described in
exercise 4.51 and <tt>if-fail</tt> as in
exercise 4.52, what will be the result of evaluating


**Exercise 4.54.** If we had not realized that <tt>require</tt> could be implemented as an
ordinary procedure that uses <tt>amb</tt>, to be defined by the user as
part of a nondeterministic program, we would have had to implement it
as a special form.  This would require syntax procedures

**Exercise 4.55.** Give simple queries that retrieve the following information from the
data base:

**Exercise 4.56.** Formulate compound queries that retrieve the following information:

**Exercise 4.57.** Define a rule that says that person 1 can replace person 2 if either
person 1 does the same job as person 2 or someone who does person 1's
job can also do person 2's job, and if person 1 and person 2 are not
the same person. Using your rule, give queries that find the
following:

**Exercise 4.58.** Define a rule that says that a person is a ``big shot'' in a division
if the person works in the division but does not have a supervisor who
works in the division.


**Exercise 4.59.** Ben Bitdiddle has missed one meeting too many.
Fearing that his habit of forgetting meetings could cost him his
job, Ben decides to do something about it.  He adds all the weekly
meetings of the firm to the Microshaft data base by
asserting the following:


**Exercise 4.60.** By giving the query


**Exercise 4.61.** The following rules implement a <tt>next-to</tt>

**Exercise 4.62.** Define rules to implement the <tt>last-pair</tt> operation of
exercise 2.17, which returns a list containing the last
element of a nonempty list.  Check your rules on queries such as
<tt>(last-pair (3) ?x)</tt>, <tt>(last-pair (1 2 3) ?x)</tt>, and <tt>(last-pair (2 ?x) (3))</tt>.
Do your rules work correctly on queries such as <tt>(last-pair ?x (3))</tt> ?


**Exercise 4.63.** The following data base (see Genesis 4) traces the genealogy of the
descendants of Ada back to Adam, by way of Cain:

**Exercise 4.64.** Louis Reasoner mistakenly deletes the <tt>outranked-by</tt> rule
(section 4.4.1) from the data base.  When
he realizes this, he quickly reinstalls it.  Unfortunately, he makes a
slight change in the rule, and types it in as

**Exercise 4.65.** Cy D. Fect, looking forward to the day when he will rise in the
organization, gives a query to find all the wheels
(using the <tt>wheel</tt> rule of section 4.4.1):

**Exercise 4.66.** Ben has been generalizing the query system to provide statistics
about the company.  For example, to find the total salaries of all the
computer programmers one will be able to say

**Exercise 4.67.** Devise a way to install a loop detector in the query system so as to
avoid the kinds of simple loops illustrated in the text and in
exercise 4.64.  The general idea is that the
system should maintain some sort of history of its current chain of
deductions and should not begin processing a query that it is already
working on.  Describe what kind of information (patterns and frames)
is included in this history, and how the check should be made.  (After
you study the details of the query-system implementation in
section 4.4.4

**Exercise 4.68.** Define rules to implement the <tt>reverse</tt> operation of
exercise 2.18, which returns a list containing the same
elements as a given list in reverse order.  (Hint: Use <tt>append-to-form</tt>.)
Can your rules answer both
<tt>(reverse (1 2 3) ?x)</tt> and <tt>(reverse ?x (1 2 3))</tt> ?


**Exercise 4.69.** Beginning with the data base and the rules you formulated in
exercise 4.63, devise a rule for adding ``greats'' to
a grandson relationship. This should enable the system to deduce that
Irad is the great-grandson of Adam, or that Jabal and Jubal are
the great-great-great-great-great-grandsons of Adam.  (Hint: Represent
the fact about Irad, for example, as <tt>((great grandson) Adam
Irad)</tt>.  Write rules that determine if a list ends in the word
<tt>grandson</tt>.  Use this to express a rule that allows one to derive
the relationship <tt>((great .  ?rel) ?x ?y)</tt>, where <tt>?rel</tt> is a
list ending in <tt>grandson</tt>.)
Check your rules on queries such as
<tt>((great grandson) ?g ?ggs)</tt> and <tt>(?relationship Adam Irad)</tt>

**Exercise 4.70.** What is the purpose of the <tt>let</tt> bindings in the procedures <tt>add-assertion!</tt> and <tt>add-rule!</tt> ?  What would be wrong with the
following implementation of <tt>add-assertion!</tt> ?
Hint: Recall the definition of the infinite stream of ones in
section 3.5.2: <tt>(define ones (cons-stream 1 ones))</tt>.

**Exercise 4.71.** Louis Reasoner wonders why the <tt>simple-query</tt> and <tt>disjoin</tt>
procedures (section 4.4.4.2) are implemented using
explicit <tt>delay</tt> operations, rather than being defined as follows:

**Exercise 4.72.** Why do <tt>disjoin</tt> and <tt>stream-flatmap</tt> interleave the
streams rather than simply append them?  Give examples that illustrate
why interleaving works better.  (Hint: Why did we use <tt>interleave</tt> in
section 3.5.3

**Exercise 4.73.** Why does <tt>flatten-stream</tt> use <tt>delay</tt> explicitly?
What would be wrong with defining it as follows:


**Exercise 4.74.** Alyssa P. Hacker proposes to use a simpler version of <tt>stream-flatmap</tt>
in <tt>negate</tt>, <tt>lisp-value</tt>, and <tt>find-assertions</tt>.
She observes that the procedure that is mapped over the frame stream
in these cases always produces either the empty stream or a singleton
stream, so no interleaving is needed when combining these streams.

**Exercise 4.75.** Implement for the query language a new special form called <tt>unique</tt>.  <tt>Unique</tt> should succeed if there is precisely one item
in the data base satisfying a specified query.  For example,

**Exercise 4.76.** Our implementation of <tt>and</tt> as a series combination of queries
(figure 4.5) is elegant, but it is inefficient because in
processing the second query of the <tt>and</tt> we must scan the data
base for each frame produced by the first query.  If the data base has
*N* elements, and a typical query produces a number of output frames
proportional to *N* (say *N*/*k*), then scanning the data base for each
frame produced by the first query will require *N*<sup>2</sup>/*k* calls to the
pattern matcher.  Another approach would be to process the two clauses
of the <tt>and</tt> separately, then look for all pairs of output frames
that are compatible.  If each query produces *N*/*k* output frames, then
this means that we must perform *N*<sup>2</sup>/*k*<sup>2</sup> compatibility checks -- a
factor of *k* fewer than the number of matches required in our current
method.

**Exercise 4.77.** In section 4.4.3 we saw that <tt>not</tt> and <tt>lisp-value</tt>

**Exercise 4.78.** Redesign the query language as a nondeterministic program to be
implemented using the evaluator of
section 4.3, rather than as a stream
process.  In this approach, each query will produce a single answer
(rather than the stream of all answers) and the user can type <tt>try-again</tt>

**Exercise 4.79.** When we implemented the Lisp evaluator in section 4.1,
we saw how to use local environments to avoid name conflicts between
the parameters of procedures.  For example, in evaluating

## 5 Computing with Register Machines
**Exercise 5.1.** Design a register machine to compute factorials using the iterative
algorithm specified by the following procedure.  Draw data-path and
controller diagrams for this machine.

**Exercise 5.2.** Use the register-machine language to describe
the iterative factorial machine of exercise 5.1.


**Exercise 5.3.** Design a machine to compute square roots using Newton's method, as
described in section 1.1.7:

**Exercise 5.4.** Specify register machines that implement each of the following
procedures.  For each machine, write a controller instruction sequence
and draw a diagram showing the data paths.

**Exercise 5.5.**

**Exercise 5.6.** Ben Bitdiddle observes that the Fibonacci machine's controller sequence
has an extra <tt>save</tt> and an extra <tt>restore</tt>, which can be
removed to make a faster machine.  Where are these instructions?


**Exercise 5.7.** Use the simulator to test the machines you designed in
exercise 5.4.


**Exercise 5.8.** The following register-machine code is ambiguous, because the label
<tt>here</tt> is defined more than once:


**Exercise 5.9.** The treatment of machine operations above permits them to operate
on labels as well as on constants and the contents of registers.
Modify the expression-processing procedures to enforce the condition
that operations can be used only with registers and constants.


**Exercise 5.10.** Design a new syntax for register-machine instructions and modify the
simulator to use your new syntax.  Can you implement your new
syntax without changing any part of the simulator except the
syntax procedures in this section?


**Exercise 5.11.** When we introduced <tt>save</tt> and <tt>restore</tt> in
section 5.1.4, we didn't specify what would happen
if you tried to restore a register that was not the last one saved, as
in the sequence

**Exercise 5.12.** The simulator can be used to help determine the data paths required
for implementing a machine with a given controller.  Extend
the assembler to store the following information in the machine model:


**Exercise 5.13.** Modify the simulator so that it uses the controller sequence to
determine what registers the machine has rather than requiring a list
of registers as an argument to <tt>make-machine</tt>.  Instead of
pre-allocating the registers in <tt>make-machine</tt>, you can allocate
them one at a time when they are first seen during assembly of the
instructions.


**Exercise 5.14.** Measure the number of pushes and the maximum stack depth required to
compute *n*! for various small values of *n* using the factorial
machine shown in figure 5.11.  From your data
determine formulas in terms of *n* for the total number of push
operations and the maximum stack depth used in computing *n*! for any
*n* &gt; 1. Note that each of these is a linear function of *n* and is
thus determined by two constants.  In order to get the statistics
printed, you will have to augment the factorial machine with instructions to
initialize the stack and print the statistics.
You may want to also modify the
machine so that it repeatedly reads a value for *n*, computes the
factorial, and prints the result (as we did for the GCD machine in
figure 5.4), so that you will not have to repeatedly
invoke <tt>get-register-contents</tt>, <tt>set-register-contents!</tt>, and
<tt>start</tt>

**Exercise 5.15.** Add *instruction counting* to the register machine simulation.
That is, have the machine model keep track of the number of
instructions executed.  Extend the machine model's interface to accept
a new message that prints the value of the instruction count and
resets the count to zero.


**Exercise 5.16.** Augment the simulator to provide for *instruction tracing*.
That is, before each instruction is executed, the simulator should print
the text of the instruction.  Make the machine model accept <tt>trace-on</tt> and
<tt>trace-off</tt> messages to turn tracing on and off.


**Exercise 5.17.** Extend the instruction tracing of
exercise 5.16 so that before
printing an instruction, the simulator prints any labels that
immediately precede that instruction in the controller sequence.  Be
careful to do this in a way that does not interfere with instruction
counting (exercise 5.15).
You will have to make the simulator retain the necessary label information.


**Exercise 5.18.** Modify the <tt>make-register</tt> procedure of
section 5.2.1 so that registers can be traced.
Registers should accept messages that turn tracing on and off.  When a
register is traced, assigning a value to the register should print the
name of the register, the old contents of the register, and the new
contents being assigned.  Extend the interface to the machine model
to permit you to turn tracing on and off for designated machine registers.


**Exercise 5.19.** Alyssa P. Hacker wants a *breakpoint* feature in the simulator to
help her debug her machine designs.  You have been hired to install
this feature for her.  She wants to be able to specify a place in the
controller sequence where the simulator will stop and allow her to
examine the state of the machine.  You are to implement a procedure

**Exercise 5.20.** Draw the box-and-pointer representation and the memory-vector
representation (as in figure 5.14) of the
list structure produced by

**Exercise 5.21.** Implement register machines for the following procedures.
Assume that the list-structure memory operations are available as
machine primitives.

**Exercise 5.22.** Exercise 3.12 of section 3.3.1
presented an <tt>append</tt> procedure that appends two lists to form a
new list and an <tt>append!</tt> procedure that splices two lists
together.  Design a register machine to implement each of these
procedures.  Assume that the list-structure memory operations are
available as primitive operations.


**Exercise 5.23.** Extend the evaluator to handle derived expressions such as <tt>cond</tt>,
<tt>let</tt>, and so on (section 4.1.2).
You may ``cheat'' and assume that the syntax
transformers such as <tt>cond-&gt;if</tt> are available as machine
operations.<sup><small>28</small></sup>

**Exercise 5.24.** Implement <tt>cond</tt> as a new basic special form without
reducing it to <tt>if</tt>.  You will have to construct a loop that tests
the predicates of successive <tt>cond</tt> clauses until you find one
that is true, and then use <tt>ev-sequence</tt>

**Exercise 5.25.** Modify the evaluator so that it uses normal-order evaluation,
based on the lazy evaluator of section 4.2.


**Exercise 5.26.** Use the monitored stack to explore the tail-recursive property of the
evaluator (section 5.4.2).  Start the
evaluator and define the iterative <tt>factorial</tt> procedure from
section 1.2.1:

**Exercise 5.27.** For comparison with exercise 5.26, explore the
behavior of the following procedure for computing factorials
recursively:


**Exercise 5.28.** Modify the definition of the evaluator by changing
<tt>eval-sequence</tt> as described in
section 5.4.2 so that the evaluator is no
longer tail-recursive.  Rerun your experiments from
exercises 5.26 and 5.27 to demonstrate
that both versions of the <tt>factorial</tt> procedure now require space
that grows linearly with their input.


**Exercise 5.29.** Monitor the stack operations in the tree-recursive Fibonacci computation:

**Exercise 5.30.** Our evaluator currently catches and signals only two kinds of
errors -- unknown expression types and unknown procedure types.  Other
errors will take us out of the evaluator read-eval-print loop.  When
we run the evaluator using the register-machine simulator, these
errors are caught by the underlying Scheme system.  This is analogous
to the computer crashing when a user program makes an
error.<sup><small>32</small></sup>  It is a large project to make a real
error system work, but it is well worth the effort to understand what
is involved here.

**Exercise 5.31.** In evaluating a procedure application, the explicit-control evaluator
always saves and restores
the <tt>env</tt> register around the evaluation of the operator, saves and
restores <tt>env</tt> around the evaluation of each operand (except the
final one), saves and restores <tt>argl</tt> around the evaluation of each
operand, and saves and restores <tt>proc</tt> around the evaluation of the
operand sequence.  For each of the following combinations, say which
of these <tt>save</tt> and <tt>restore</tt> operations are superfluous and
thus could be eliminated by the compiler's <tt>preserving</tt> mechanism:

**Exercise 5.32.** Using the <tt>preserving</tt> mechanism, the compiler will avoid saving
and restoring <tt>env</tt> around the evaluation of the operator of a
combination in the case where the operator is a symbol.  We could also
build such optimizations into the evaluator.  Indeed, the
explicit-control evaluator of section 5.4 already
performs a similar optimization, by treating combinations with no
operands as a special case.

**Exercise 5.33.** Consider the following definition of a factorial procedure, which is
slightly different from the one given above:


**Exercise 5.34.** Compile the iterative factorial procedure


**Exercise 5.35.** What expression was compiled to produce the code shown in
figure 5.18?


**Exercise 5.36.** What order of evaluation does our compiler produce for operands of a
combination?  Is it left-to-right, right-to-left, or some other order?
Where in the compiler is this order determined?  Modify the compiler
so that it produces some other order of evaluation.  (See the
discussion of order of evaluation for the explicit-control evaluator
in section 5.4.1.)  How does changing the order of
operand evaluation affect the efficiency of the code that constructs
the argument list?


**Exercise 5.37.** One way to understand the compiler's <tt>preserving</tt> mechanism for
optimizing stack usage is to see what extra operations would
be generated if we did not use this idea.  Modify <tt>preserving</tt> so
that it always generates the <tt>save</tt> and <tt>restore</tt> operations.
Compile some simple expressions and identify the unnecessary stack
operations that are generated.
Compare the code to that generated with the <tt>preserving</tt> mechanism intact.


**Exercise 5.38.** Our compiler is clever about avoiding unnecessary stack operations,
but it is not clever at all when it comes to compiling calls to the primitive
procedures of the language in terms of the primitive operations
supplied by the machine.  For example, consider how much code is
compiled to compute <tt>(+ a 1)</tt>: The code sets up an argument list
in <tt>argl</tt>, puts the primitive addition procedure (which it finds
by looking up the symbol <tt>+</tt> in the environment) into <tt>proc</tt>,
and tests whether the procedure is primitive or compound.  The
compiler always generates code to perform the test, as well as code
for primitive and compound branches (only one of which will be executed).
We have not shown the part of the controller that implements
primitives, but we presume that these instructions make use of
primitive arithmetic operations in the machine's data paths.  Consider
how much less code would be generated if the compiler could *open-code* primitives -- that is, if it could generate code to directly
use these primitive machine operations.  The expression <tt>(+ a 1)</tt>
might be compiled into something as simple as <sup><small>43</small></sup>

**Exercise 5.39.** Write a procedure <tt>lexical-address-lookup</tt> that implements the new
lookup operation.  It should take two arguments -- a lexical address
and a run-time environment -- and return the value of the variable
stored at the specified lexical address.  <tt>Lexical-address-lookup</tt>
should signal an error if the value of the variable is the symbol <tt>*unassigned*</tt>.<sup><small>46</small></sup> Also write a procedure <tt>lexical-address-set!</tt>

**Exercise 5.40.** Modify the compiler to maintain the compile-time environment as
described above.  That is, add a compile-time-environment argument to
<tt>compile</tt> and the various code generators, and extend it in
<tt>compile-lambda-body</tt>.


**Exercise 5.41.** Write a procedure <tt>find-variable</tt> that takes as arguments a
variable and a compile-time environment and returns the lexical
address of the variable with respect to that environment.  For
example, in the program fragment that is shown above, the compile-time
environment during the compilation of expression &lt;*e1*&gt; is <tt>((y
z) (a b c d e) (x y))</tt>.  <tt>Find-variable</tt> should produce

**Exercise 5.42.** Using <tt>find-variable</tt> from exercise 5.41,
rewrite <tt>compile-variable</tt> and <tt>compile-assignment</tt> to output
lexical-address instructions.  In cases where <tt>find-variable</tt>
returns <tt>not-found</tt> (that is, where the variable is not in the
compile-time environment), you should have the code generators use the
evaluator operations, as before, to search for the binding.
(The only place a variable that is not found at compile time can be is in
the global environment, which is part of the run-time environment but
is not part of the compile-time environment.<sup><small>47</small></sup>
Thus, if you wish, you may have the evaluator operations look directly in
the global environment, which can be obtained with the operation <tt>(op&nbsp;get-global-environment)</tt>, instead of having them search the whole run-time
environment found in <tt>env</tt>.)
Test the modified compiler on a few simple cases, such as the nested
<tt>lambda</tt>

**Exercise 5.43.** We argued in section 4.1.6 that internal definitions
for block structure should not be considered ``real'' <tt>define</tt>s.  Rather,
a procedure body should be interpreted as if the internal variables being
defined were installed as ordinary <tt>lambda</tt> variables initialized to their
correct values using <tt>set!</tt>.  Section 4.1.6 and
exercise 4.16

**Exercise 5.44.** In this section we have focused on the use of the compile-time
environment to produce lexical addresses.  But there are other uses
for compile-time environments.  For instance, in
exercise 5.38 we increased the efficiency of compiled
code by open-coding primitive procedures.  Our implementation treated
the names of open-coded procedures as reserved words.  If a program
were to rebind such a name, the mechanism described in
exercise 5.38 would still open-code it as a primitive,
ignoring the new binding.  For example, consider the procedure

**Exercise 5.45.** By comparing the stack operations used by compiled code to the stack
operations used by the evaluator for the same computation, we can
determine the extent to which the compiler optimizes use of the stack,
both in speed (reducing the total number of stack operations) and in
space (reducing the maximum stack depth).  Comparing this optimized
stack use to the performance of a special-purpose machine for the same
computation gives some indication of the quality of the compiler.

**Exercise 5.46.** Carry out an analysis like the one in
exercise 5.45 to determine the effectiveness of
compiling the tree-recursive Fibonacci procedure

**Exercise 5.47.** This section described how to modify the explicit-control evaluator so
that interpreted code can call compiled procedures.  Show how to
modify the compiler so that compiled procedures can call not only
primitive procedures and compiled procedures, but interpreted
procedures as well.  This requires modifying <tt>compile-procedure-call</tt>
to handle the case of compound (interpreted) procedures.
Be sure to handle all the same <tt>target</tt> and <tt>linkage</tt> combinations
as in <tt>compile-proc-appl</tt>.  To do the actual procedure application,
the code needs to jump to the evaluator's <tt>compound-apply</tt> entry point.
This label cannot be directly referenced in object code
(since the assembler requires that all labels referenced by the
code it is assembling be defined there), so we will add a register
called <tt>compapp</tt> to the evaluator machine to hold this
entry point, and add an instruction to initialize it:


**Exercise 5.48.** The <tt>compile-and-go</tt> interface implemented in this section is
awkward, since the compiler can be called only once (when the
evaluator machine is started).  Augment the compiler-interpreter
interface by providing a <tt>compile-and-run</tt> primitive that can be
called from within the explicit-control evaluator as follows:

**Exercise 5.49.** As an alternative to using the explicit-control evaluator's
read-eval-print loop, design a register machine that performs a
read-compile-execute-print loop.  That is, the machine should run a
loop that reads an expression, compiles it, assembles and
executes the resulting code, and prints the result.  This is easy to
run in our simulated setup, since we can arrange to call the
procedures <tt>compile</tt> and <tt>assemble</tt>

**Exercise 5.50.** Use the compiler to compile the metacircular evaluator of
section 4.1 and run this program using the register-machine
simulator.  (To compile more than one definition at a time, you can
package the definitions in a <tt>begin</tt>.)  The resulting interpreter
will run very slowly because of the multiple levels of interpretation,
but getting all the details to work is an instructive exercise.


**Exercise 5.51.** Develop a rudimentary implementation of Scheme in C (or some other
low-level language of your choice) by translating the explicit-control
evaluator of section 5.4

**Exercise 5.52.** As a counterpoint to exercise 5.51, modify the compiler
so that it compiles Scheme procedures into sequences of C
instructions.  Compile the metacircular evaluator of
section 4.1

